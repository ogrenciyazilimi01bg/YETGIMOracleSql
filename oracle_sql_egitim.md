# 8 Saatlik Oracle SQL EÄŸitimi
## HR (Human Resources) Veri TabanÄ± ile UygulamalÄ± SQL EÄŸitimi

---

## ğŸ“š SQL VE VERÄ° TABANI TEMELLERÄ°

### Veri TabanÄ± Nedir?
Veri tabanÄ±, organize edilmiÅŸ veri koleksiyonudur. Bilgilerin sistematik olarak depolandÄ±ÄŸÄ±, yÃ¶netildiÄŸi ve eriÅŸildiÄŸi dijital depodur.

**Veri TabanÄ±nÄ±n FaydalarÄ±:**
- **Veri TutarlÄ±lÄ±ÄŸÄ±**: AynÄ± verinin farklÄ± yerlerde farklÄ± deÄŸerlerde olmasÄ±nÄ± Ã¶nler
- **Veri BÃ¼tÃ¼nlÃ¼ÄŸÃ¼**: Verilerin doÄŸruluÄŸunu ve geÃ§erliliÄŸini saÄŸlar
- **EÅŸzamanlÄ± EriÅŸim**: Birden fazla kullanÄ±cÄ±nÄ±n aynÄ± anda veri iÅŸlemesi
- **GÃ¼venlik**: Yetkilendirme ve kimlik doÄŸrulama sistemleri
- **Yedekleme ve Kurtarma**: Veri kaybÄ±na karÅŸÄ± koruma

### Ä°liÅŸkisel Veri TabanÄ± Modeli

Ä°liÅŸkisel veri tabanlarÄ±, **Dr. Edgar F. Codd** tarafÄ±ndan 1970 yÄ±lÄ±nda geliÅŸtirilen matematiksel bir model Ã¼zerine kurulmuÅŸtur. Bu model, verileri **tablolar** (relations) halinde organize eder ve tablolar arasÄ±nda **iliÅŸkiler** kurarak veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ saÄŸlar.

#### **Temel Kavramlar:**
- **Tablo (Table/Relation)**: Verilerin depolandÄ±ÄŸÄ± iki boyutlu yapÄ±
- **SatÄ±r (Row/Record/Tuple)**: Tek bir veri kaydÄ±
- **SÃ¼tun (Column/Field/Attribute)**: Belirli bir veri tÃ¼rÃ¼nÃ¼ temsil eden alan
- **Domain**: Bir sÃ¼tunun alabileceÄŸi deÄŸerler kÃ¼mesi
- **Cardinality**: Tablodaki satÄ±r sayÄ±sÄ±
- **Degree**: Tablodaki sÃ¼tun sayÄ±sÄ±

#### **Primary Key (Birincil Anahtar) - PK**

Primary Key, her kaydÄ± benzersiz olarak tanÄ±mlayan sÃ¼tun veya sÃ¼tun kombinasyonudur.

**Primary Key Ã–zellikleri:**
- **Benzersiz (Unique)**: Her deÄŸer tabloda sadece bir kez bulunabilir
- **Null Olamaz**: HiÃ§bir PK deÄŸeri NULL olamaz
- **DeÄŸiÅŸmez**: PK deÄŸerleri mÃ¼mkÃ¼n olduÄŸunca deÄŸiÅŸtirilmemelidir
- **Minimal**: En az sÃ¼tun sayÄ±sÄ± ile tanÄ±mlanmalÄ±

**Primary Key TÃ¼rleri:**

1. **Simple Primary Key (Tek SÃ¼tunlu)**
```sql
CREATE TABLE EMPLOYEES (
    EMPLOYEE_ID NUMBER PRIMARY KEY,  -- Tek sÃ¼tunlu PK
    FIRST_NAME VARCHAR2(50),
    LAST_NAME VARCHAR2(50)
);
```

2. **Composite Primary Key (Ã‡ok SÃ¼tunlu)**
```sql
CREATE TABLE ORDER_ITEMS (
    ORDER_ID NUMBER,
    PRODUCT_ID NUMBER,
    QUANTITY NUMBER,
    PRICE NUMBER,
    PRIMARY KEY (ORDER_ID, PRODUCT_ID)  -- Ä°ki sÃ¼tunlu PK
);
```

3. **Surrogate Key (Yapay Anahtar)**
```sql
CREATE TABLE CUSTOMERS (
    CUSTOMER_ID NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,  -- Otomatik artan
    CUSTOMER_NAME VARCHAR2(100),
    EMAIL VARCHAR2(100)
);
```

#### **Foreign Key (YabancÄ± Anahtar) - FK**

Foreign Key, bir tablodaki sÃ¼tunun baÅŸka bir tablonun Primary Key'ini referans etmesidir.

**Foreign Key Ã–zellikleri:**
- **Referential Integrity**: Referans edilen deÄŸer mutlaka var olmalÄ±
- **Null Olabilir**: FK deÄŸerleri NULL olabilir (opsiyonel iliÅŸki)
- **Cascade Options**: Ana kayÄ±t silindiÄŸinde ne yapÄ±lacaÄŸÄ±nÄ± belirler

**Foreign Key Ã–rneÄŸi:**
```sql
-- Ana tablo (Referenced Table)
CREATE TABLE DEPARTMENTS (
    DEPARTMENT_ID NUMBER PRIMARY KEY,
    DEPARTMENT_NAME VARCHAR2(50)
);

-- BaÄŸÄ±mlÄ± tablo (Referencing Table)
CREATE TABLE EMPLOYEES (
    EMPLOYEE_ID NUMBER PRIMARY KEY,
    FIRST_NAME VARCHAR2(50),
    DEPARTMENT_ID NUMBER,  -- Foreign Key
    CONSTRAINT fk_emp_dept 
        FOREIGN KEY (DEPARTMENT_ID) 
        REFERENCES DEPARTMENTS(DEPARTMENT_ID)
);
```

#### **Ä°liÅŸki TÃ¼rleri (Relationship Types)**

##### **1. One-to-One (1:1) Ä°liÅŸki**
Bir tablodaki her kayÄ±t, diÄŸer tabloda en fazla bir kayÄ±tla eÅŸleÅŸir.

```sql
-- Ã–rnek: Her Ã§alÄ±ÅŸanÄ±n tek bir detay kaydÄ±
EMPLOYEES (PK: EMPLOYEE_ID)
    â†• (1:1)
EMPLOYEE_DETAILS (PK: EMPLOYEE_ID, FK: EMPLOYEE_ID)

CREATE TABLE EMPLOYEE_DETAILS (
    EMPLOYEE_ID NUMBER PRIMARY KEY,
    SOCIAL_SECURITY_NO VARCHAR2(20),
    BIRTH_DATE DATE,
    CONSTRAINT fk_emp_details 
        FOREIGN KEY (EMPLOYEE_ID) 
        REFERENCES EMPLOYEES(EMPLOYEE_ID)
);
```

##### **2. One-to-Many (1:N) Ä°liÅŸki**
Bir tablodaki bir kayÄ±t, diÄŸer tabloda birden fazla kayÄ±tla eÅŸleÅŸebilir.

```sql
-- Ã–rnek: Bir departmanda birden fazla Ã§alÄ±ÅŸan
DEPARTMENTS (PK: DEPARTMENT_ID)
    â†• (1:N)
EMPLOYEES (PK: EMPLOYEE_ID, FK: DEPARTMENT_ID)

-- Bir departman birden fazla Ã§alÄ±ÅŸana sahip olabilir
-- Bir Ã§alÄ±ÅŸan sadece bir departmanda Ã§alÄ±ÅŸÄ±r
```

##### **3. Many-to-Many (N:M) Ä°liÅŸki**
Her iki tablodaki kayÄ±tlar birden fazla kayÄ±tla eÅŸleÅŸebilir. Bu tÃ¼r iliÅŸkiler **junction table** ile Ã§Ã¶zÃ¼lÃ¼r.

```sql
-- Ã–rnek: Ã‡alÄ±ÅŸanlar birden fazla projede Ã§alÄ±ÅŸabilir
-- Projelerde birden fazla Ã§alÄ±ÅŸan bulunabilir

EMPLOYEES (PK: EMPLOYEE_ID)
    â†• (N:M)
PROJECTS (PK: PROJECT_ID)

-- Junction Table (Ara Tablo)
CREATE TABLE EMPLOYEE_PROJECTS (
    EMPLOYEE_ID NUMBER,
    PROJECT_ID NUMBER,
    START_DATE DATE,
    END_DATE DATE,
    PRIMARY KEY (EMPLOYEE_ID, PROJECT_ID),
    FOREIGN KEY (EMPLOYEE_ID) REFERENCES EMPLOYEES(EMPLOYEE_ID),
    FOREIGN KEY (PROJECT_ID) REFERENCES PROJECTS(PROJECT_ID)
);
```

#### **Referential Integrity (Referans BÃ¼tÃ¼nlÃ¼ÄŸÃ¼)**

Referans bÃ¼tÃ¼nlÃ¼ÄŸÃ¼, FK deÄŸerlerinin her zaman geÃ§erli PK deÄŸerlerini gÃ¶stermesini saÄŸlar.

**Cascade Options:**

```sql
-- ON DELETE CASCADE: Ana kayÄ±t silindiÄŸinde baÄŸÄ±mlÄ± kayÄ±tlar da silinir
FOREIGN KEY (DEPARTMENT_ID) REFERENCES DEPARTMENTS(DEPARTMENT_ID) ON DELETE CASCADE

-- ON DELETE SET NULL: Ana kayÄ±t silindiÄŸinde FK deÄŸeri NULL yapÄ±lÄ±r
FOREIGN KEY (DEPARTMENT_ID) REFERENCES DEPARTMENTS(DEPARTMENT_ID) ON DELETE SET NULL

-- ON DELETE RESTRICT: Ana kayÄ±t silinmesini engeller (default)
FOREIGN KEY (DEPARTMENT_ID) REFERENCES DEPARTMENTS(DEPARTMENT_ID)
```

#### **Entity Relationship Diagram (ERD) Temelleri**

ERD, veri tabanÄ± tasarÄ±mÄ±nÄ± gÃ¶rsel olarak temsil eden diyagramdÄ±r.

**ERD Sembolleri:**
- **DikdÃ¶rtgen**: Entity (Tablo)
- **Elips**: Attribute (SÃ¼tun)
- **Baklava**: Relationship (Ä°liÅŸki)
- **Ã‡izgiler**: Ä°liÅŸki baÄŸlantÄ±larÄ±

**HR Veri TabanÄ± ERD Ã–rneÄŸi:**
```
[REGIONS] â”€â”€â”¬â”€â”€< [COUNTRIES] â”€â”€â”¬â”€â”€< [LOCATIONS] â”€â”€â”¬â”€â”€< [DEPARTMENTS] â”€â”€â”¬â”€â”€< [EMPLOYEES]
            â”‚                  â”‚                  â”‚                   â”‚
           1:N                1:N                1:N                 1:N
                                                                      â”‚
                                                                      â””â”€â”€> [JOB_HISTORY]
                                                                     N:1
[JOBS] â”€â”€â”¬â”€â”€< [EMPLOYEES]
         â”‚
        1:N
```

#### **ACID Properties (Atomicity, Consistency, Isolation, Durability)**

Ä°liÅŸkisel veri tabanlarÄ±nÄ±n gÃ¼venilirliÄŸini saÄŸlayan dÃ¶rt temel Ã¶zellik:

1. **Atomicity (Atomiklik)**: Transaction ya tamamen gerÃ§ekleÅŸir ya da hiÃ§ gerÃ§ekleÅŸmez
2. **Consistency (TutarlÄ±lÄ±k)**: Veri tabanÄ± her zaman geÃ§erli durumda kalÄ±r
3. **Isolation (Ä°zolasyon)**: EÅŸ zamanlÄ± iÅŸlemler birbirini etkilemez
4. **Durability (DayanÄ±klÄ±lÄ±k)**: Tamamlanan iÅŸlemler kalÄ±cÄ±dÄ±r

#### **Ä°liÅŸkisel Veri TabanÄ± AvantajlarÄ±**

**1. Veri BÃ¼tÃ¼nlÃ¼ÄŸÃ¼**
- Primary Key ile benzersizlik garantisi
- Foreign Key ile referans doÄŸruluÄŸu
- Check constraint'ler ile veri geÃ§erliliÄŸi

**2. Veri TutarlÄ±lÄ±ÄŸÄ±**
- Normalizasyon ile tekrar azaltma
- Transaction desteÄŸi ile tutarlÄ± gÃ¼ncellemeler

**3. Esneklik**
- SQL ile gÃ¼Ã§lÃ¼ sorgulama yetenekleri
- Ä°liÅŸkiler sayesinde complex raporlama

**4. GÃ¼venlik**
- KullanÄ±cÄ± bazlÄ± yetkilendirme
- Rol ve privilege sistemi

**5. Performans**
- Index desteÄŸi
- Query optimization

#### **Ä°liÅŸkisel Model KurallarÄ± (Codd's Rules)**

Dr. Codd'un tanÄ±mladÄ±ÄŸÄ± 12 temel kural:
1. **Information Rule**: TÃ¼m bilgi tablolarda saklanÄ±r
2. **Guaranteed Access Rule**: Her veri deÄŸerine tabloismi+PK+sÃ¼tunismi ile eriÅŸilebilir
3. **Systematic Treatment of Null**: NULL deÄŸerler sistematik olarak iÅŸlenir
4. **Dynamic Catalog**: Veri tabanÄ± yapÄ±sÄ± da tablolarda saklanÄ±r
5. **Comprehensive Data Sublanguage**: SQL gibi tam Ã¶zellikli dil
6. **View Updating Rule**: View'lar mÃ¼mkÃ¼n olduÄŸunca gÃ¼ncellenebilir
7. **High-level Insert, Update, Delete**: Set bazlÄ± iÅŸlemler
8. **Physical Data Independence**: Fiziksel deÄŸiÅŸiklikler uygulamayÄ± etkilemez
9. **Logical Data Independence**: MantÄ±ksal deÄŸiÅŸiklikler uygulamayÄ± etkilemez
10. **Integrity Independence**: BÃ¼tÃ¼nlÃ¼k kurallarÄ± DBMS'de tanÄ±mlanÄ±r
11. **Distribution Independence**: DaÄŸÄ±tÄ±k yapÄ± uygulamayÄ± etkilemez
12. **Non-subversion Rule**: Alt seviye eriÅŸim bÃ¼tÃ¼nlÃ¼ÄŸÃ¼ bozamaz

#### **Pratik Ã–rnek: HR Veri TabanÄ± Ä°liÅŸkileri**

```sql
-- 1. REGIONS (Ana tablo)
REGIONS
- REGION_ID (PK)
- REGION_NAME

-- 2. COUNTRIES (REGIONS'a baÄŸlÄ±)  
COUNTRIES
- COUNTRY_ID (PK)
- COUNTRY_NAME
- REGION_ID (FK â†’ REGIONS.REGION_ID)

-- 3. LOCATIONS (COUNTRIES'e baÄŸlÄ±)
LOCATIONS  
- LOCATION_ID (PK)
- CITY
- COUNTRY_ID (FK â†’ COUNTRIES.COUNTRY_ID)

-- 4. DEPARTMENTS (LOCATIONS'a baÄŸlÄ±)
DEPARTMENTS
- DEPARTMENT_ID (PK) 
- DEPARTMENT_NAME
- LOCATION_ID (FK â†’ LOCATIONS.LOCATION_ID)
- MANAGER_ID (FK â†’ EMPLOYEES.EMPLOYEE_ID) -- Self reference

-- 5. EMPLOYEES (DEPARTMENTS'a baÄŸlÄ±)
EMPLOYEES
- EMPLOYEE_ID (PK)
- FIRST_NAME, LAST_NAME
- DEPARTMENT_ID (FK â†’ DEPARTMENTS.DEPARTMENT_ID)
- MANAGER_ID (FK â†’ EMPLOYEES.EMPLOYEE_ID) -- Self reference
- JOB_ID (FK â†’ JOBS.JOB_ID)

-- 6. JOBS (Lookup table)
JOBS
- JOB_ID (PK)
- JOB_TITLE
- MIN_SALARY, MAX_SALARY

-- 7. JOB_HISTORY (Many-to-Many resolver)
JOB_HISTORY
- EMPLOYEE_ID (PK, FK â†’ EMPLOYEES.EMPLOYEE_ID)
- START_DATE (PK)
- END_DATE
- JOB_ID (FK â†’ JOBS.JOB_ID)
- DEPARTMENT_ID (FK â†’ DEPARTMENTS.DEPARTMENT_ID)
```

**Bu yapÄ±nÄ±n mantÄ±ÄŸÄ±:**
- **HiyerarÅŸik Ä°liÅŸki**: Region â†’ Country â†’ Location â†’ Department â†’ Employee
- **Lookup Ä°liÅŸki**: Job â†” Employee (iÅŸ tanÄ±mlarÄ±)
- **Self Reference**: Employee â†” Manager (organizasyon hiyerarÅŸisi)
- **Historical Tracking**: Job_History (geÃ§miÅŸ iÅŸ kayÄ±tlarÄ±)

**Ã–rnek Tablo YapÄ±sÄ±:**
```
EMPLOYEES Tablosu:
+-------------+------------+-----------+--------+---------------+------------+
| EMPLOYEE_ID | FIRST_NAME | LAST_NAME | SALARY | DEPARTMENT_ID | MANAGER_ID |
+-------------+------------+-----------+--------+---------------+------------+
| 100         | Steven     | King      | 24000  | 90            | NULL       |
| 101         | Neena      | Kochhar   | 17000  | 90            | 100        |
| 102         | Lex        | De Haan   | 17000  | 90            | 100        |
+-------------+------------+-----------+--------+---------------+------------+
     â†‘              â†‘                              â†‘               â†‘
   PK (Primary Key)                        FK (Foreign Key)   Self-Reference FK
```

### SQL'in Tarihi ve Ã–nemi

**SQL (Structured Query Language)**
- **1970**: Dr. Edgar F. Codd iliÅŸkisel model teorisini geliÅŸtirir
- **1974**: IBM'de System R projesi baÅŸlar
- **1982**: IBM SQL/DS Ã¼rÃ¼nÃ¼nÃ¼ piyasaya sÃ¼rer
- **1986**: SQL ANSI standardÄ± olur
- **1989**: SQL2 (SQL-89) standardÄ±
- **1999**: SQL3 (SQL-99) standardÄ± - Object-oriented Ã¶zellikler
- **2003**: SQL:2003 standardÄ± - XML Ã¶zellikleri
- **2016**: SQL:2016 standardÄ± - JSON desteÄŸi

### SQL Komut TÃ¼rleri

#### 1. **DDL (Data Definition Language) - Veri TanÄ±mlama Dili**
Veri tabanÄ± yapÄ±sÄ±nÄ± tanÄ±mlar ve deÄŸiÅŸtirir.
```sql
CREATE TABLE employees (id NUMBER, name VARCHAR2(50));
ALTER TABLE employees ADD email VARCHAR2(100);
DROP TABLE old_table;
```

#### 2. **DML (Data Manipulation Language) - Veri Ä°ÅŸleme Dili** 
Verileri sorgular, ekler, gÃ¼nceller ve siler.
```sql
SELECT * FROM employees;
INSERT INTO employees VALUES (1, 'John Doe');
UPDATE employees SET salary = 5000 WHERE id = 1;
DELETE FROM employees WHERE id = 1;
```

#### 3. **DCL (Data Control Language) - Veri Kontrol Dili**
EriÅŸim yetkilerini yÃ¶netir.
```sql
GRANT SELECT ON employees TO user1;
REVOKE INSERT ON employees FROM user2;
```

#### 4. **TCL (Transaction Control Language) - Ä°ÅŸlem Kontrol Dili**
Ä°ÅŸlem akÄ±ÅŸÄ±nÄ± kontrol eder.
```sql
COMMIT;    -- DeÄŸiÅŸiklikleri kalÄ±cÄ± yapar
ROLLBACK;  -- DeÄŸiÅŸiklikleri geri alÄ±r
SAVEPOINT sp1;  -- Geri dÃ¶nÃ¼ÅŸ noktasÄ± oluÅŸturur
```

### Normalizasyon Temelleri

Normalizasyon, veri tekrarÄ±nÄ± azaltmak ve veri bÃ¼tÃ¼nlÃ¼ÄŸÃ¼nÃ¼ saÄŸlamak iÃ§in tablolarÄ± organize etme sÃ¼recidir.

**1. Normal Form (1NF):**
- Her sÃ¼tun atomik deÄŸerler iÃ§ermeli
- Tekrarlayan gruplar olmamalÄ±

**2. Normal Form (2NF):**
- 1NF ÅŸartlarÄ±nÄ± saÄŸlamalÄ±
- Primary key'e tam baÄŸÄ±mlÄ±lÄ±k olmalÄ±

**3. Normal Form (3NF):**
- 2NF ÅŸartlarÄ±nÄ± saÄŸlamalÄ±
- GeÃ§iÅŸken baÄŸÄ±mlÄ±lÄ±k olmamalÄ±

**Normalizasyon Ã–rneÄŸi:**

**Normalizasyon Ã–ncesi (KÃ¶tÃ¼ TasarÄ±m):**
```
EMPLOYEES_BAD:
+-------+-----------+---------------+------------+
| ID    | NAME      | DEPARTMENTS   | DEPT_LOCS  |
+-------+-----------+---------------+------------+
| 1     | John      | IT,Sales      | NY,Boston  |
| 2     | Jane      | HR            | Chicago    |
+-------+-----------+---------------+------------+
```

**Normalizasyon SonrasÄ± (Ä°yi TasarÄ±m):**
```
EMPLOYEES:                    DEPARTMENTS:
+----+---------+             +----------+---------------+
| ID | NAME    |             | DEPT_ID  | DEPT_NAME     |
+----+---------+             +----------+---------------+
| 1  | John    |             | 10       | IT            |
| 2  | Jane    |             | 20       | Sales         |
+----+---------+             | 30       | HR            |
                              +----------+---------------+

EMPLOYEE_DEPARTMENTS:
+-------------+----------+
| EMPLOYEE_ID | DEPT_ID  |
+-------------+----------+
| 1           | 10       |
| 1           | 20       |
| 2           | 30       |
+-------------+----------+
```

---

## ğŸ” ORACLE SQL'Ä°N DÄ°ÄER SQL DÄ°LLERÄ°NDEN FARKLARI

### Oracle SQL vs. DiÄŸer RDBMS'ler

Oracle SQL, ANSI SQL standardÄ±nÄ± takip etmekle birlikte kendine Ã¶zgÃ¼ birÃ§ok Ã¶zellik ve syntax'a sahiptir.

### 1. **Oracle'a Ã–zel Fonksiyonlar**

#### **DUAL Tablosu**
Oracle'da sistem fonksiyonlarÄ±nÄ± test etmek iÃ§in Ã¶zel bir tablo.
```sql
-- Oracle
SELECT SYSDATE FROM DUAL;
SELECT 2+2 FROM DUAL;

-- SQL Server / MySQL
SELECT GETDATE();
SELECT 2+2;
```

#### **NVL vs. ISNULL/COALESCE**
```sql
-- Oracle
SELECT NVL(commission_pct, 0) FROM employees;
SELECT NVL2(commission_pct, 'Has Commission', 'No Commission') FROM employees;

-- SQL Server
SELECT ISNULL(commission_pct, 0) FROM employees;

-- MySQL/PostgreSQL (Standart)
SELECT COALESCE(commission_pct, 0) FROM employees;
```

#### **DECODE Fonksiyonu (Oracle'a Ã–zel)**
```sql
-- Oracle
SELECT DECODE(department_id, 
    10, 'Accounting',
    20, 'Research', 
    30, 'Sales',
    'Other') AS dept_name
FROM employees;

-- DiÄŸer RDBMS'ler (CASE WHEN kullanÄ±r)
SELECT CASE department_id
    WHEN 10 THEN 'Accounting'
    WHEN 20 THEN 'Research'
    WHEN 30 THEN 'Sales'
    ELSE 'Other'
END AS dept_name
FROM employees;
```

### 2. **Tarih Ä°ÅŸlemleri**

#### **Tarih FormatlarÄ±**
```sql
-- Oracle
SELECT TO_CHAR(SYSDATE, 'DD-MON-YYYY HH24:MI:SS') FROM DUAL;
SELECT TO_DATE('2023-12-31', 'YYYY-MM-DD') FROM DUAL;

-- SQL Server
SELECT FORMAT(GETDATE(), 'dd-MMM-yyyy HH:mm:ss');
SELECT CAST('2023-12-31' AS DATE);

-- MySQL
SELECT DATE_FORMAT(NOW(), '%d-%b-%Y %H:%i:%s');
SELECT STR_TO_DATE('2023-12-31', '%Y-%m-%d');
```

#### **Tarih AritmetiÄŸi**
```sql
-- Oracle (DoÄŸrudan + - operatÃ¶rleri)
SELECT SYSDATE + 30 FROM DUAL;  -- 30 gÃ¼n sonra
SELECT SYSDATE - SYSDATE-1 FROM DUAL;  -- GÃ¼n farkÄ±

-- SQL Server
SELECT DATEADD(day, 30, GETDATE());
SELECT DATEDIFF(day, date1, date2);

-- MySQL
SELECT DATE_ADD(NOW(), INTERVAL 30 DAY);
SELECT DATEDIFF(date1, date2);
```

### 3. **String Ä°ÅŸlemleri**

#### **String BirleÅŸtirme**
```sql
-- Oracle
SELECT first_name || ' ' || last_name AS full_name FROM employees;
SELECT CONCAT(first_name, last_name) FROM employees;

-- SQL Server
SELECT first_name + ' ' + last_name AS full_name FROM employees;
SELECT CONCAT(first_name, ' ', last_name) FROM employees;

-- MySQL
SELECT CONCAT(first_name, ' ', last_name) AS full_name FROM employees;

-- PostgreSQL
SELECT first_name || ' ' || last_name AS full_name FROM employees;
```

#### **Substring Ä°ÅŸlemleri**
```sql
-- Oracle
SELECT SUBSTR(first_name, 1, 3) FROM employees;

-- SQL Server
SELECT SUBSTRING(first_name, 1, 3) FROM employees;

-- MySQL
SELECT SUBSTRING(first_name, 1, 3) FROM employees;
SELECT LEFT(first_name, 3) FROM employees;
```

### 4. **Analytic Functions (Oracle'Ä±n GÃ¼Ã§lÃ¼ YanÄ±)**

Oracle, window functions konusunda diÄŸer RDBMS'lerden Ã¶nce geliÅŸmiÅŸ Ã¶zelliklere sahiptir.

```sql
-- Oracle (GeliÅŸmiÅŸ Window Functions)
SELECT first_name, salary,
    ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) as rn,
    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as rnk,
    DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) as d_rnk,
    LAG(salary, 1) OVER (PARTITION BY department_id ORDER BY salary) as prev_sal,
    LEAD(salary, 1) OVER (PARTITION BY department_id ORDER BY salary) as next_sal
FROM employees;

-- Oracle'a Ã¶zel LISTAGG
SELECT department_id,
    LISTAGG(first_name, ', ') WITHIN GROUP (ORDER BY first_name) as emp_list
FROM employees
GROUP BY department_id;
```

### 5. **HiyerarÅŸik Sorgular**

#### **CONNECT BY (Oracle'a Ã–zel)**
```sql
-- Oracle
SELECT LEVEL, employee_id, first_name, manager_id
FROM employees
START WITH manager_id IS NULL
CONNECT BY PRIOR employee_id = manager_id;

-- SQL Server (Recursive CTE)
WITH EmployeeHierarchy AS (
    SELECT employee_id, first_name, manager_id, 1 as Level
    FROM employees
    WHERE manager_id IS NULL
    
    UNION ALL
    
    SELECT e.employee_id, e.first_name, e.manager_id, eh.Level + 1
    FROM employees e
    INNER JOIN EmployeeHierarchy eh ON e.manager_id = eh.employee_id
)
SELECT * FROM EmployeeHierarchy;
```

### 6. **Sayfalama (Pagination)**

#### **ROWNUM vs. LIMIT vs. TOP**
```sql
-- Oracle (ROWNUM - eski yÃ¶ntem)
SELECT * FROM (
    SELECT * FROM employees ORDER BY salary DESC
) WHERE ROWNUM <= 10;

-- Oracle 12c+ (OFFSET FETCH - modern)
SELECT * FROM employees 
ORDER BY salary DESC
OFFSET 0 ROWS FETCH NEXT 10 ROWS ONLY;

-- MySQL
SELECT * FROM employees 
ORDER BY salary DESC
LIMIT 10;

-- SQL Server
SELECT TOP 10 * FROM employees 
ORDER BY salary DESC;

-- PostgreSQL
SELECT * FROM employees 
ORDER BY salary DESC
LIMIT 10;
```

### 7. **Sequence'lar**

#### **Auto-increment YaklaÅŸÄ±mlarÄ±**
```sql
-- Oracle (Sequence)
CREATE SEQUENCE emp_seq START WITH 1 INCREMENT BY 1;
INSERT INTO employees (employee_id, first_name) 
VALUES (emp_seq.NEXTVAL, 'John');

-- SQL Server (Identity)
CREATE TABLE employees (
    employee_id INT IDENTITY(1,1),
    first_name VARCHAR(50)
);

-- MySQL (Auto_increment)
CREATE TABLE employees (
    employee_id INT AUTO_INCREMENT PRIMARY KEY,
    first_name VARCHAR(50)
);

-- PostgreSQL (Serial)
CREATE TABLE employees (
    employee_id SERIAL PRIMARY KEY,
    first_name VARCHAR(50)
);
```

### 8. **Error Handling**

```sql
-- Oracle (PL/SQL)
BEGIN
    INSERT INTO employees VALUES (1, 'John');
EXCEPTION
    WHEN DUP_VAL_ON_INDEX THEN
        DBMS_OUTPUT.PUT_LINE('Duplicate value error');
END;

-- SQL Server
BEGIN TRY
    INSERT INTO employees VALUES (1, 'John');
END TRY
BEGIN CATCH
    PRINT 'Error occurred: ' + ERROR_MESSAGE();
END CATCH;
```

### 9. **Veri TÃ¼rleri FarklarÄ±**

| Oracle | SQL Server | MySQL | PostgreSQL |
|--------|------------|--------|------------|
| VARCHAR2(4000) | VARCHAR(8000) | VARCHAR(65535) | VARCHAR |
| NUMBER | INT, DECIMAL | INT, DECIMAL | INTEGER, NUMERIC |
| DATE | DATETIME | DATETIME | TIMESTAMP |
| CLOB | TEXT | LONGTEXT | TEXT |
| BLOB | VARBINARY(MAX) | LONGBLOB | BYTEA |

### 10. **Oracle'Ä±n AvantajlarÄ±**

#### **Performans ve Ã–lÃ§eklenebilirlik**
- **Partitioning**: BÃ¼yÃ¼k tablolarÄ± bÃ¶lÃ¼mlere ayÄ±rma
- **Parallel Processing**: SorgularÄ± paralel Ã§alÄ±ÅŸtÄ±rma
- **Advanced Compression**: GeliÅŸmiÅŸ sÄ±kÄ±ÅŸtÄ±rma teknikleri

#### **GeliÅŸmiÅŸ Ã–zellikler**
- **Flashback Technology**: Verileri geÃ§miÅŸe dÃ¶ndÃ¼rme
- **Real Application Clusters (RAC)**: Ã‡oklu sunucu desteÄŸi
- **Advanced Security**: GeliÅŸmiÅŸ gÃ¼venlik Ã¶zellikleri
- **In-Memory Database**: Bellek iÃ§i iÅŸlemler

#### **Analitik Yetenekler**
- **OLAP Functions**: Ã‡ok boyutlu analiz
- **Data Mining**: Veri madenciliÄŸi araÃ§larÄ±  
- **Statistical Functions**: Ä°statistiksel fonksiyonlar

### Oracle SQL Ã–ÄŸrenirken Dikkat Edilecekler

1. **Case Sensitivity**: Oracle tablo ve sÃ¼tun isimlerinde case-sensitive deÄŸildir
2. **NULL Handling**: Empty string ('') NULL olarak deÄŸerlendirilir
3. **Date Format**: Default tarih formatÄ± 'DD-MON-YY'
4. **Schema**: Oracle'da schema kullanÄ±cÄ± ile aynÄ±dÄ±r
5. **Semicolon**: SQL komutlarÄ± semicolon (;) ile biter

---

## ğŸ“‹ EÄÄ°TÄ°M MÃœFREDATÄ±

### **1. Saat (1. Oturum) - SQL Temelleri ve Veri TabanÄ± TanÄ±tÄ±mÄ±**
- SQL nedir? Neden Ã¶nemlidir?
- Oracle Live SQL platformu tanÄ±tÄ±mÄ±
- HR veri tabanÄ± ÅŸemasÄ± tanÄ±tÄ±mÄ±
- Temel SQL komutlarÄ± (SELECT, FROM, WHERE)
- Ä°lk sorgu yazÄ±mÄ±

### **2. Saat (2. Oturum) - SELECT SorgularÄ± ve Veri Filtreleme**
- WHERE koÅŸullarÄ± ve operatÃ¶rleri
- ORDER BY ile sÄ±ralama
- DISTINCT kullanÄ±mÄ±
- KarÅŸÄ±laÅŸtÄ±rma operatÃ¶rleri
- MantÄ±ksal operatÃ¶rleri (AND, OR, NOT)

### **3. Saat (3. Oturum) - Fonksiyonlar ve Veri ManipÃ¼lasyonu**
- String fonksiyonlarÄ±
- SayÄ±sal fonksiyonlarÄ±
- Tarih fonksiyonlarÄ±
- NULL deÄŸerler ve COALESCE
- CASE WHEN yapÄ±sÄ±

### **4. Saat (4. Oturum) - GruplandÄ±rma ve Toplama FonksiyonlarÄ±**
- GROUP BY kullanÄ±mÄ±
- Toplama fonksiyonlarÄ± (COUNT, SUM, AVG, MIN, MAX)
- HAVING koÅŸulu
- GruplanmÄ±ÅŸ veri analizi

### **5. Saat (5. Oturum) - Ã‡oklu Tablo Ä°ÅŸlemleri - JOIN'ler**
- INNER JOIN
- LEFT/RIGHT OUTER JOIN
- FULL OUTER JOIN
- SELF JOIN
- Pratik JOIN Ã¶rnekleri

### **6. Saat (6. Oturum) - Alt Sorgular (Subqueries)**
- Basit alt sorgular
- Correlated subqueries
- IN, EXISTS kullanÄ±mÄ±
- Alt sorgu optimizasyonu

### **7. Saat (7. Oturum) - GeliÅŸmiÅŸ SQL KonularÄ±**
- UNION ve UNION ALL
- Analytic fonksiyonlar (ROW_NUMBER, RANK, DENSE_RANK)
- Window functions
- WITH (CTE) kullanÄ±mÄ±

### **8. Saat (8. Oturum) - Pratik Uygulamalar ve Ä°nceleme**
- GerÃ§ek senaryolar Ã¼zerinde kompleks sorgular
- Performans ipuÃ§larÄ±
- Best practices
- Soru-cevap ve deÄŸerlendirme

---

## ğŸ“– EÄÄ°TÄ°M DÃ–KÃœMANI

## **1. OTURUM: SQL TEMELLERÄ° VE VERÄ° TABANI TANITIMI**

### SQL Nedir?
SQL (Structured Query Language), iliÅŸkisel veri tabanlarÄ±nda veri sorgulamak, eklemek, gÃ¼ncellemek ve silmek iÃ§in kullanÄ±lan standart dildir.

### Oracle Live SQL'e GiriÅŸ
1. https://livesql.oracle.com adresine gidin
2. Oracle hesabÄ±nÄ±zla giriÅŸ yapÄ±n
3. "Sample Datasets" bÃ¶lÃ¼mÃ¼nden "Human Resources (HR)" veri setini seÃ§in

### HR Veri TabanÄ± ÅemasÄ±
HR veri tabanÄ± ÅŸu tablolarÄ± iÃ§erir:

**HR.EMPLOYEES** - Ã‡alÄ±ÅŸan bilgileri
- EMPLOYEE_ID (Ã‡alÄ±ÅŸan ID)
- FIRST_NAME (Ad)
- LAST_NAME (Soyad)
- EMAIL (E-posta)
- PHONE_NUMBER (Telefon)
- HIRE_DATE (Ä°ÅŸe baÅŸlama tarihi)
- JOB_ID (Ä°ÅŸ pozisyonu ID)
- SALARY (MaaÅŸ)
- COMMISSION_PCT (Komisyon oranÄ±)
- MANAGER_ID (YÃ¶netici ID)
- DEPARTMENT_ID (Departman ID)

**HR.DEPARTMENTS** - Departman bilgileri
- DEPARTMENT_ID (Departman ID)
- DEPARTMENT_NAME (Departman adÄ±)
- MANAGER_ID (YÃ¶netici ID)
- LOCATION_ID (Lokasyon ID)

**HR.JOBS** - Ä°ÅŸ pozisyonlarÄ±
- JOB_ID (Ä°ÅŸ ID)
- JOB_TITLE (Ä°ÅŸ unvanÄ±)
- MIN_SALARY (Minimum maaÅŸ)
- MAX_SALARY (Maksimum maaÅŸ)

**HR.LOCATIONS** - Lokasyon bilgileri
- LOCATION_ID (Lokasyon ID)
- STREET_ADDRESS (Adres)
- POSTAL_CODE (Posta kodu)
- CITY (Åehir)
- STATE_PROVINCE (Eyalet/Ä°l)
- COUNTRY_ID (Ãœlke ID)

**HR.COUNTRIES** - Ãœlke bilgileri
- COUNTRY_ID (Ãœlke ID)
- COUNTRY_NAME (Ãœlke adÄ±)
- REGION_ID (BÃ¶lge ID)

**HR.REGIONS** - BÃ¶lge bilgileri
- REGION_ID (BÃ¶lge ID)
- REGION_NAME (BÃ¶lge adÄ±)

**HR.JOB_HISTORY** - Ä°ÅŸ geÃ§miÅŸi
- EMPLOYEE_ID (Ã‡alÄ±ÅŸan ID)
- START_DATE (BaÅŸlangÄ±Ã§ tarihi)
- END_DATE (BitiÅŸ tarihi)
- JOB_ID (Ä°ÅŸ ID)
- DEPARTMENT_ID (Departman ID)

### Ä°lk SQL Sorgunuz

```sql
-- TÃ¼m Ã§alÄ±ÅŸanlarÄ± listele
SELECT * FROM HR.EMPLOYEES;

-- Sadece ad ve soyad bilgilerini getir
SELECT FIRST_NAME, LAST_NAME FROM HR.EMPLOYEES;

-- Ä°lk 5 Ã§alÄ±ÅŸanÄ± getir
SELECT * FROM HR.EMPLOYEES WHERE ROWNUM <= 5;
```

### Pratik AlÄ±ÅŸtÄ±rma 1
```sql
-- 1. TÃ¼m departmanlarÄ± listeleyin
SELECT * FROM HR.DEPARTMENTS;

-- 2. TÃ¼m iÅŸ pozisyonlarÄ±nÄ± listeleyin
SELECT * FROM HR.JOBS;

-- 3. Ã‡alÄ±ÅŸanlarÄ±n sadece adÄ±nÄ± ve maaÅŸÄ±nÄ± listeleyin
SELECT FIRST_NAME, SALARY FROM HR.EMPLOYEES;

-- 4. TÃ¼m lokasyonlarÄ± listeleyin
SELECT * FROM HR.LOCATIONS;

-- 5. TÃ¼m Ã¼lkeleri listeleyin
SELECT * FROM HR.COUNTRIES;
```

## ğŸ‹ï¸ **OTURUM 1 - ALIÅTIRMALAR**

### **KOLAY SEVÄ°YE (3 Soru)**

**1. HR ÅŸemasÄ±ndaki tÃ¼m Ã§alÄ±ÅŸanlarÄ±n sayÄ±sÄ±nÄ± bulun.**
```sql
-- SORU 1 CEVABI:
SELECT COUNT(*) AS TOPLAM_CALISAN 
FROM HR.EMPLOYEES;
```

**2. Ã‡alÄ±ÅŸanlarÄ±n sadece ad, soyad ve e-posta bilgilerini listeleyin.**
```sql
-- SORU 2 CEVABI:
SELECT FIRST_NAME, LAST_NAME, EMAIL 
FROM HR.EMPLOYEES;
```

**3. TÃ¼m bÃ¶lgelerin (regions) isimlerini alfabetik sÄ±raya gÃ¶re listeleyin.**
```sql
-- SORU 3 CEVABI:
SELECT REGION_NAME 
FROM HR.REGIONS 
ORDER BY REGION_NAME ASC;
```

### **ORTA SEVÄ°YE (3 Soru)**

**4. Ä°lk 10 Ã§alÄ±ÅŸanÄ±n bilgilerini maaÅŸ sÄ±rasÄ±na gÃ¶re (yÃ¼ksekten dÃ¼ÅŸÃ¼ÄŸe) listeleyin.**
```sql
-- SORU 4 CEVABI:
SELECT FIRST_NAME, LAST_NAME, SALARY 
FROM HR.EMPLOYEES 
ORDER BY SALARY DESC 
FETCH FIRST 10 ROWS ONLY;
```

**5. Ã‡alÄ±ÅŸanlarÄ±n tam adÄ±nÄ± (Ad Soyad) tek sÃ¼tunda gÃ¶sterin ve bu sÃ¼tuna "TAM_AD" adÄ±nÄ± verin.**
```sql
-- SORU 5 CEVABI:
SELECT FIRST_NAME || ' ' || LAST_NAME AS TAM_AD 
FROM HR.EMPLOYEES;
```

**6. KaÃ§ farklÄ± Ã¼lkede ofis bulunduÄŸunu hesaplayÄ±n.**
```sql
-- SORU 6 CEVABI:
SELECT COUNT(DISTINCT COUNTRY_ID) AS FARKLI_ULKE_SAYISI 
FROM HR.LOCATIONS;
```

### **ZOR SEVÄ°YE (2 Soru)**

**7. En yÃ¼ksek ve en dÃ¼ÅŸÃ¼k maaÅŸÄ± alan Ã§alÄ±ÅŸanlarÄ±n bilgilerini tek bir sorguda gÃ¶sterin.**
```sql
-- SORU 7 CEVABI:
SELECT FIRST_NAME, LAST_NAME, SALARY,
       CASE 
           WHEN SALARY = (SELECT MAX(SALARY) FROM HR.EMPLOYEES) THEN 'EN YÃœKSEK'
           WHEN SALARY = (SELECT MIN(SALARY) FROM HR.EMPLOYEES) THEN 'EN DÃœÅÃœK'
       END AS MAAÅ_DURUMU
FROM HR.EMPLOYEES 
WHERE SALARY = (SELECT MAX(SALARY) FROM HR.EMPLOYEES) 
   OR SALARY = (SELECT MIN(SALARY) FROM HR.EMPLOYEES);
```

**8. Åirketin toplam maaÅŸ giderini hesaplayÄ±n ve sonucu formatlanmÄ±ÅŸ olarak gÃ¶sterin.**
```sql
-- SORU 8 CEVABI:
SELECT TO_CHAR(SUM(SALARY), '999,999,999') AS TOPLAM_MAAÅ_GIDERI,
       TO_CHAR(AVG(SALARY), '999,999.99') AS ORTALAMA_MAAÅ
FROM HR.EMPLOYEES;
```

---

## **2. OTURUM: SELECT SORGULARI VE VERÄ° FÄ°LTRELEME**

### WHERE KoÅŸullarÄ±

```sql
-- Belirli bir departmandaki Ã§alÄ±ÅŸanlar
SELECT * FROM HR.EMPLOYEES WHERE DEPARTMENT_ID = 10;

-- MaaÅŸÄ± 5000'den bÃ¼yÃ¼k Ã§alÄ±ÅŸanlar
SELECT FIRST_NAME, LAST_NAME, SALARY 
FROM HR.EMPLOYEES 
WHERE SALARY > 5000;

-- Belirli bir tarihten sonra iÅŸe baÅŸlayanlar
SELECT FIRST_NAME, LAST_NAME, HIRE_DATE 
FROM HR.EMPLOYEES 
WHERE HIRE_DATE > DATE '2005-01-01';
```

### KarÅŸÄ±laÅŸtÄ±rma OperatÃ¶rleri

```sql
-- EÅŸitlik
SELECT * FROM HR.EMPLOYEES WHERE JOB_ID = 'IT_PROG';

-- EÅŸitsizlik
SELECT * FROM HR.EMPLOYEES WHERE DEPARTMENT_ID != 10;

-- AralÄ±k belirtme
SELECT * FROM HR.EMPLOYEES WHERE SALARY BETWEEN 5000 AND 10000;

-- Liste iÃ§inde arama
SELECT * FROM HR.EMPLOYEES WHERE DEPARTMENT_ID IN (10, 20, 30);

-- Pattern matching
SELECT * FROM HR.EMPLOYEES WHERE LAST_NAME LIKE 'K%';

-- NULL deÄŸer kontrolÃ¼
SELECT * FROM HR.EMPLOYEES WHERE COMMISSION_PCT IS NULL;
```

### MantÄ±ksal OperatÃ¶rler

```sql
-- AND kullanÄ±mÄ±
SELECT * FROM HR.EMPLOYEES 
WHERE DEPARTMENT_ID = 10 AND SALARY > 5000;

-- OR kullanÄ±mÄ±
SELECT * FROM HR.EMPLOYEES 
WHERE DEPARTMENT_ID = 10 OR DEPARTMENT_ID = 20;

-- NOT kullanÄ±mÄ±
SELECT * FROM HR.EMPLOYEES 
WHERE NOT DEPARTMENT_ID = 10;
```

### SÄ±ralama (ORDER BY)

```sql
-- MaaÅŸa gÃ¶re artan sÄ±ralama
SELECT FIRST_NAME, LAST_NAME, SALARY 
FROM HR.EMPLOYEES 
ORDER BY SALARY ASC;

-- MaaÅŸa gÃ¶re azalan sÄ±ralama
SELECT FIRST_NAME, LAST_NAME, SALARY 
FROM HR.EMPLOYEES 
ORDER BY SALARY DESC;

-- Ã‡oklu sÄ±ralama
SELECT FIRST_NAME, LAST_NAME, DEPARTMENT_ID, SALARY 
FROM HR.EMPLOYEES 
ORDER BY DEPARTMENT_ID ASC, SALARY DESC;
```

### DISTINCT KullanÄ±mÄ±

```sql
-- Benzersiz departman ID'leri
SELECT DISTINCT DEPARTMENT_ID FROM HR.EMPLOYEES;

-- Benzersiz iÅŸ pozisyonlarÄ±
SELECT DISTINCT JOB_ID FROM HR.EMPLOYEES;

-- Benzersiz ÅŸehirler
SELECT DISTINCT CITY FROM HR.LOCATIONS;
```

### Pratik AlÄ±ÅŸtÄ±rma 2
```sql
-- 1. MaaÅŸÄ± 8000'den bÃ¼yÃ¼k Ã§alÄ±ÅŸanlarÄ± maaÅŸ sÄ±rasÄ±na gÃ¶re listeleyin
SELECT FIRST_NAME, LAST_NAME, SALARY 
FROM HR.EMPLOYEES 
WHERE SALARY > 8000 
ORDER BY SALARY DESC;

-- 2. SoyadÄ± 'A' ile baÅŸlayan Ã§alÄ±ÅŸanlarÄ± bulun
SELECT * FROM HR.EMPLOYEES WHERE LAST_NAME LIKE 'A%';

-- 3. IT departmanÄ±ndaki Ã§alÄ±ÅŸanlarÄ± listeleyin (JOB_ID 'IT' ile baÅŸlayanlar)
SELECT * FROM HR.EMPLOYEES WHERE JOB_ID LIKE 'IT%';

-- 4. 2006 yÄ±lÄ±nda iÅŸe baÅŸlayan Ã§alÄ±ÅŸanlarÄ± bulun
SELECT FIRST_NAME, LAST_NAME, HIRE_DATE 
FROM HR.EMPLOYEES 
WHERE EXTRACT(YEAR FROM HIRE_DATE) = 2006;
```

## ğŸ‹ï¸ **OTURUM 2 - ALIÅTIRMALAR**

### **KOLAY SEVÄ°YE (3 Soru)**

**1. MaaÅŸÄ± 5000 ile 10000 arasÄ±nda olan Ã§alÄ±ÅŸanlarÄ± listeleyin.**
```sql
-- SORU 1 CEVABI:
SELECT FIRST_NAME, LAST_NAME, SALARY 
FROM HR.EMPLOYEES 
WHERE SALARY BETWEEN 5000 AND 10000
ORDER BY SALARY;
```

**2. Komisyon alan Ã§alÄ±ÅŸanlarÄ± listeleyin (COMMISSION_PCT NULL olmayan).**
```sql
-- SORU 2 CEVABI:
SELECT FIRST_NAME, LAST_NAME, COMMISSION_PCT, SALARY
FROM HR.EMPLOYEES 
WHERE COMMISSION_PCT IS NOT NULL
ORDER BY COMMISSION_PCT DESC;
```

**3. Departman ID'si 10, 20 veya 30 olan Ã§alÄ±ÅŸanlarÄ± bulun.**
```sql
-- SORU 3 CEVABI:
SELECT FIRST_NAME, LAST_NAME, DEPARTMENT_ID 
FROM HR.EMPLOYEES 
WHERE DEPARTMENT_ID IN (10, 20, 30)
ORDER BY DEPARTMENT_ID;
```

### **ORTA SEVÄ°YE (3 Soru)**

**4. Ä°smi 'A' harfi ile baÅŸlayan VE maaÅŸÄ± 7000'den bÃ¼yÃ¼k olan Ã§alÄ±ÅŸanlarÄ± bulun.**
```sql
-- SORU 4 CEVABI:
SELECT FIRST_NAME, LAST_NAME, SALARY 
FROM HR.EMPLOYEES 
WHERE FIRST_NAME LIKE 'A%' AND SALARY > 7000
ORDER BY SALARY DESC;
```

**5. 2005 ile 2007 yÄ±llarÄ± arasÄ±nda iÅŸe alÄ±nan Ã§alÄ±ÅŸanlarÄ± listeleyin.**
```sql
-- SORU 5 CEVABI:
SELECT FIRST_NAME, LAST_NAME, HIRE_DATE 
FROM HR.EMPLOYEES 
WHERE HIRE_DATE BETWEEN DATE '2005-01-01' AND DATE '2007-12-31'
ORDER BY HIRE_DATE;
```

**6. Ä°ÅŸ pozisyonu 'CLERK' ile biten VEYA maaÅŸÄ± 15000'den bÃ¼yÃ¼k olan Ã§alÄ±ÅŸanlarÄ± bulun.**
```sql
-- SORU 6 CEVABI:
SELECT FIRST_NAME, LAST_NAME, JOB_ID, SALARY 
FROM HR.EMPLOYEES 
WHERE JOB_ID LIKE '%CLERK' OR SALARY > 15000
ORDER BY SALARY DESC;
```

### **ZOR SEVÄ°YE (2 Soru)**

**7. Telefon numarasÄ± olmayan VEYA telefon numarasÄ± '515' ile baÅŸlamayan Ã§alÄ±ÅŸanlarÄ± bulun.**
```sql
-- SORU 7 CEVABI:
SELECT FIRST_NAME, LAST_NAME, PHONE_NUMBER 
FROM HR.EMPLOYEES 
WHERE PHONE_NUMBER IS NULL OR PHONE_NUMBER NOT LIKE '515%'
ORDER BY PHONE_NUMBER NULLS LAST;
```

**8. Her ayÄ±n ilk 10 gÃ¼nÃ¼ iÃ§inde iÅŸe baÅŸlayan Ã§alÄ±ÅŸanlarÄ± bulun ve iÅŸe baÅŸladÄ±klarÄ± ayÄ± da gÃ¶sterin.**
```sql
-- SORU 8 CEVABI:
SELECT FIRST_NAME, LAST_NAME, HIRE_DATE,
       EXTRACT(DAY FROM HIRE_DATE) AS GUN,
       TO_CHAR(HIRE_DATE, 'MONTH') AS AY,
       EXTRACT(YEAR FROM HIRE_DATE) AS YIL
FROM HR.EMPLOYEES 
WHERE EXTRACT(DAY FROM HIRE_DATE) <= 10
ORDER BY HIRE_DATE;
```

---

## **3. OTURUM: FONKSÄ°YONLAR VE VERÄ° MANÄ°PÃœLASYONU**

### String FonksiyonlarÄ±

```sql
-- BÃ¼yÃ¼k/kÃ¼Ã§Ã¼k harf dÃ¶nÃ¼ÅŸÃ¼mÃ¼
SELECT UPPER(FIRST_NAME), LOWER(LAST_NAME), INITCAP(EMAIL)
FROM HR.EMPLOYEES;

-- String birleÅŸtirme
SELECT FIRST_NAME || ' ' || LAST_NAME AS FULL_NAME
FROM HR.EMPLOYEES;

-- CONCAT fonksiyonu
SELECT CONCAT(FIRST_NAME, LAST_NAME) AS FULL_NAME
FROM HR.EMPLOYEES;

-- String uzunluÄŸu
SELECT FIRST_NAME, LENGTH(FIRST_NAME) AS NAME_LENGTH
FROM HR.EMPLOYEES;

-- Alt string
SELECT FIRST_NAME, SUBSTR(FIRST_NAME, 1, 3) AS SHORT_NAME
FROM HR.EMPLOYEES;

-- String deÄŸiÅŸtirme
SELECT FIRST_NAME, REPLACE(FIRST_NAME, 'A', '*') AS MODIFIED_NAME
FROM HR.EMPLOYEES;
```

### SayÄ±sal Fonksiyonlar

```sql
-- Yuvarlama
SELECT SALARY, ROUND(SALARY/12, 2) AS MONTHLY_SALARY
FROM HR.EMPLOYEES;

-- YukarÄ±/aÅŸaÄŸÄ± yuvarlama
SELECT SALARY, CEIL(SALARY/12) AS MONTHLY_CEIL, FLOOR(SALARY/12) AS MONTHLY_FLOOR
FROM HR.EMPLOYEES;

-- Mutlak deÄŸer
SELECT ABS(-100) FROM DUAL;

-- Modulo
SELECT MOD(SALARY, 1000) FROM HR.EMPLOYEES;

-- GÃ¼Ã§ alma
SELECT POWER(2, 3) FROM DUAL;
```

### Tarih FonksiyonlarÄ±

```sql
-- BugÃ¼nÃ¼n tarihi
SELECT SYSDATE FROM DUAL;

-- Tarih farkÄ± (gÃ¼n olarak)
SELECT FIRST_NAME, HIRE_DATE, SYSDATE - HIRE_DATE AS DAYS_WORKED
FROM HR.EMPLOYEES;

-- Tarih ekleme/Ã§Ä±karma
SELECT HIRE_DATE, HIRE_DATE + 30 AS THIRTY_DAYS_LATER
FROM HR.EMPLOYEES;

-- Ay ekleme
SELECT HIRE_DATE, ADD_MONTHS(HIRE_DATE, 6) AS SIX_MONTHS_LATER
FROM HR.EMPLOYEES;

-- Tarihin parÃ§alarÄ±nÄ± alma
SELECT HIRE_DATE, 
       EXTRACT(YEAR FROM HIRE_DATE) AS HIRE_YEAR,
       EXTRACT(MONTH FROM HIRE_DATE) AS HIRE_MONTH,
       EXTRACT(DAY FROM HIRE_DATE) AS HIRE_DAY
FROM HR.EMPLOYEES;

-- Tarih formatÄ±
SELECT HIRE_DATE, TO_CHAR(HIRE_DATE, 'DD-MON-YYYY') AS FORMATTED_DATE
FROM HR.EMPLOYEES;
```

### NULL DeÄŸerler ve COALESCE

```sql
-- NULL deÄŸerleri kontrol etme
SELECT FIRST_NAME, COMMISSION_PCT
FROM HR.EMPLOYEES
WHERE COMMISSION_PCT IS NULL;

-- NULL olmayan deÄŸerler
SELECT FIRST_NAME, COMMISSION_PCT
FROM HR.EMPLOYEES
WHERE COMMISSION_PCT IS NOT NULL;

-- COALESCE ile NULL deÄŸer yerine varsayÄ±lan deÄŸer
SELECT FIRST_NAME, COALESCE(COMMISSION_PCT, 0) AS COMMISSION
FROM HR.EMPLOYEES;

-- NVL fonksiyonu (Oracle'a Ã¶zel)
SELECT FIRST_NAME, NVL(COMMISSION_PCT, 0) AS COMMISSION
FROM HR.EMPLOYEES;

-- NVL2 fonksiyonu
SELECT FIRST_NAME, NVL2(COMMISSION_PCT, 'Has Commission', 'No Commission') AS COMMISSION_STATUS
FROM HR.EMPLOYEES;
```

### CASE WHEN YapÄ±sÄ±

```sql
-- Basit CASE WHEN
SELECT FIRST_NAME, SALARY,
       CASE 
           WHEN SALARY < 5000 THEN 'DÃ¼ÅŸÃ¼k'
           WHEN SALARY BETWEEN 5000 AND 10000 THEN 'Orta'
           ELSE 'YÃ¼ksek'
       END AS SALARY_CATEGORY
FROM HR.EMPLOYEES;

-- Departman adlarÄ±nÄ± kategorilemek
SELECT FIRST_NAME, DEPARTMENT_ID,
       CASE DEPARTMENT_ID
           WHEN 10 THEN 'Accounting'
           WHEN 20 THEN 'Research'
           WHEN 30 THEN 'Sales'
           ELSE 'Other'
       END AS DEPT_CATEGORY
FROM HR.EMPLOYEES;

-- Ã‡alÄ±ÅŸma sÃ¼resine gÃ¶re kategori
SELECT FIRST_NAME, HIRE_DATE,
       CASE 
           WHEN MONTHS_BETWEEN(SYSDATE, HIRE_DATE) > 120 THEN 'Veteran'
           WHEN MONTHS_BETWEEN(SYSDATE, HIRE_DATE) > 60 THEN 'Experienced'
           ELSE 'New'
       END AS EXPERIENCE_LEVEL
FROM HR.EMPLOYEES;
```

### Pratik AlÄ±ÅŸtÄ±rma 3
```sql
-- 1. Ã‡alÄ±ÅŸanlarÄ±n tam adÄ±nÄ± (Ad Soyad) ve e-posta adreslerini bÃ¼yÃ¼k harfle gÃ¶sterin
SELECT UPPER(FIRST_NAME || ' ' || LAST_NAME) AS FULL_NAME, 
       UPPER(EMAIL) AS EMAIL
FROM HR.EMPLOYEES;

-- 2. Ã‡alÄ±ÅŸanlarÄ±n Ã§alÄ±ÅŸma sÃ¼resini yÄ±l olarak hesaplayÄ±n
SELECT FIRST_NAME, LAST_NAME, HIRE_DATE,
       ROUND(MONTHS_BETWEEN(SYSDATE, HIRE_DATE) / 12, 1) AS YEARS_WORKED
FROM HR.EMPLOYEES;

-- 3. MaaÅŸ kategorisi ve komisyon durumu analizi
SELECT FIRST_NAME, SALARY, COMMISSION_PCT,
       CASE 
           WHEN SALARY > 10000 THEN 'Senior'
           WHEN SALARY > 5000 THEN 'Mid-level'
           ELSE 'Junior'
       END AS LEVEL,
       NVL(COMMISSION_PCT, 0) AS COMMISSION
FROM HR.EMPLOYEES;

-- 4. Email adresinden domain kÄ±smÄ±nÄ± Ã§Ä±karÄ±n
SELECT EMAIL, SUBSTR(EMAIL, INSTR(EMAIL, '@') + 1) AS EMAIL_DOMAIN
FROM HR.EMPLOYEES;
```

## ğŸ‹ï¸ **OTURUM 3 - ALIÅTIRMALAR**

### **KOLAY SEVÄ°YE (3 Soru)**

**1. TÃ¼m Ã§alÄ±ÅŸanlarÄ±n adlarÄ±nÄ±n ilk 3 harfini bÃ¼yÃ¼k harfle gÃ¶sterin.**
```sql
-- SORU 1 CEVABI:
SELECT FIRST_NAME, 
       UPPER(SUBSTR(FIRST_NAME, 1, 3)) AS FIRST_3_LETTERS
FROM HR.EMPLOYEES;
```

**2. Ã‡alÄ±ÅŸanlarÄ±n maaÅŸlarÄ±nÄ± ayda ne kadar aldÄ±klarÄ±nÄ± hesaplayÄ±p 2 ondalÄ±k ile gÃ¶sterin.**
```sql
-- SORU 2 CEVABI:
SELECT FIRST_NAME, LAST_NAME, SALARY,
       ROUND(SALARY / 12, 2) AS MONTHLY_SALARY
FROM HR.EMPLOYEES;
```

**3. Komisyon oranÄ± NULL olan Ã§alÄ±ÅŸanlar iÃ§in 'Komisyon Yok' yazÄ±sÄ±nÄ± gÃ¶sterin.**
```sql
-- SORU 3 CEVABI:
SELECT FIRST_NAME, LAST_NAME,
       NVL2(COMMISSION_PCT, TO_CHAR(COMMISSION_PCT), 'Komisyon Yok') AS COMMISSION_STATUS
FROM HR.EMPLOYEES;
```

### **ORTA SEVÄ°YE (3 Soru)**

**4. Ã‡alÄ±ÅŸanlarÄ±n iÅŸe baÅŸladÄ±klarÄ± gÃ¼nÃ¼n haftanÄ±n hangi gÃ¼nÃ¼ olduÄŸunu bulun.**
```sql
-- SORU 4 CEVABI:
SELECT FIRST_NAME, LAST_NAME, HIRE_DATE,
       TO_CHAR(HIRE_DATE, 'DAY') AS HIRE_DAY_OF_WEEK,
       TO_CHAR(HIRE_DATE, 'DD-MON-YYYY') AS FORMATTED_HIRE_DATE
FROM HR.EMPLOYEES
ORDER BY HIRE_DATE;
```

**5. E-posta adresini kÃ¼Ã§Ã¼k harfle gÃ¶sterin ve '@' iÅŸaretinden Ã¶nceki kÄ±smÄ± da ayrÄ± bir sÃ¼tunda gÃ¶sterin.**
```sql
-- SORU 5 CEVABI:
SELECT FIRST_NAME, LAST_NAME,
       LOWER(EMAIL) AS EMAIL_LOWER,
       SUBSTR(EMAIL, 1, INSTR(EMAIL, '@') - 1) AS USERNAME
FROM HR.EMPLOYEES;
```

**6. MaaÅŸa gÃ¶re performans kategorisi belirleyin ve Ã§alÄ±ÅŸma yÄ±llarÄ±na gÃ¶re de deneyim seviyesi ekleyin.**
```sql
-- SORU 6 CEVABI:
SELECT FIRST_NAME, LAST_NAME, SALARY, HIRE_DATE,
       CASE 
           WHEN SALARY >= 15000 THEN 'YÃ¼ksek Performans'
           WHEN SALARY >= 8000 THEN 'Orta Performans'
           ELSE 'BaÅŸlangÄ±Ã§ Seviye'
       END AS PERFORMANCE_LEVEL,
       CASE 
           WHEN MONTHS_BETWEEN(SYSDATE, HIRE_DATE) >= 120 THEN 'Uzman' -- 10+ yÄ±l
           WHEN MONTHS_BETWEEN(SYSDATE, HIRE_DATE) >= 60 THEN 'Deneyimli' -- 5+ yÄ±l
           ELSE 'Yeni'
       END AS EXPERIENCE_LEVEL
FROM HR.EMPLOYEES;
```

### **ZOR SEVÄ°YE (2 Soru)**

**7. Ã‡alÄ±ÅŸanlarÄ±n adlarÄ±ndaki sesli harf sayÄ±sÄ±nÄ± hesaplayÄ±n.**
```sql
-- SORU 7 CEVABI:
SELECT FIRST_NAME,
       LENGTH(FIRST_NAME) - LENGTH(REPLACE(REPLACE(REPLACE(REPLACE(REPLACE(
           UPPER(FIRST_NAME), 'A', ''), 'E', ''), 'I', ''), 'O', ''), 'U', '')) AS VOWEL_COUNT
FROM HR.EMPLOYEES
ORDER BY VOWEL_COUNT DESC;
```

**8. Her Ã§alÄ±ÅŸan iÃ§in maaÅŸÄ±nÄ±n ÅŸirket ortalamasÄ±ndan kaÃ§ kat fazla/az olduÄŸunu hesaplayÄ±n.**
```sql
-- SORU 8 CEVABI:
SELECT FIRST_NAME, LAST_NAME, SALARY,
       (SELECT ROUND(AVG(SALARY), 2) FROM HR.EMPLOYEES) AS COMPANY_AVG,
       ROUND(SALARY / (SELECT AVG(SALARY) FROM HR.EMPLOYEES), 2) AS SALARY_RATIO,
       CASE 
           WHEN SALARY > (SELECT AVG(SALARY) FROM HR.EMPLOYEES) THEN 
               'Ortalamadan ' || TO_CHAR(ROUND((SALARY / (SELECT AVG(SALARY) FROM HR.EMPLOYEES) - 1) * 100, 1)) || '% yÃ¼ksek'
           ELSE 
               'Ortalamadan ' || TO_CHAR(ROUND((1 - SALARY / (SELECT AVG(SALARY) FROM HR.EMPLOYEES)) * 100, 1)) || '% dÃ¼ÅŸÃ¼k'
       END AS COMPARISON_TO_AVG
FROM HR.EMPLOYEES
ORDER BY SALARY_RATIO DESC;
```

---

## **4. OTURUM: GRUPLANDIRMA VE TOPLAMA FONKSÄ°YONLARI**

### Temel Toplama FonksiyonlarÄ±

```sql
-- TÃ¼m Ã§alÄ±ÅŸan sayÄ±sÄ±
SELECT COUNT(*) AS TOTAL_EMPLOYEES FROM HR.EMPLOYEES;

-- NULL olmayan komisyon sayÄ±sÄ±
SELECT COUNT(COMMISSION_PCT) AS EMPLOYEES_WITH_COMMISSION FROM HR.EMPLOYEES;

-- Toplam maaÅŸ
SELECT SUM(SALARY) AS TOTAL_SALARY FROM HR.EMPLOYEES;

-- Ortalama maaÅŸ
SELECT AVG(SALARY) AS AVERAGE_SALARY FROM HR.EMPLOYEES;

-- En yÃ¼ksek ve en dÃ¼ÅŸÃ¼k maaÅŸ
SELECT MAX(SALARY) AS HIGHEST_SALARY, MIN(SALARY) AS LOWEST_SALARY 
FROM HR.EMPLOYEES;

-- Toplam departman sayÄ±sÄ±
SELECT COUNT(*) AS TOTAL_DEPARTMENTS FROM HR.DEPARTMENTS;

-- Toplam lokasyon sayÄ±sÄ±
SELECT COUNT(*) AS TOTAL_LOCATIONS FROM HR.LOCATIONS;
```

### GROUP BY KullanÄ±mÄ±

```sql
-- Departmana gÃ¶re Ã§alÄ±ÅŸan sayÄ±sÄ±
SELECT DEPARTMENT_ID, COUNT(*) AS EMPLOYEE_COUNT
FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID
ORDER BY DEPARTMENT_ID;

-- Departmana gÃ¶re ortalama maaÅŸ
SELECT DEPARTMENT_ID, 
       COUNT(*) AS EMP_COUNT,
       AVG(SALARY) AS AVG_SALARY,
       MIN(SALARY) AS MIN_SALARY,
       MAX(SALARY) AS MAX_SALARY
FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID;

-- Ä°ÅŸ pozisyonuna gÃ¶re maaÅŸ istatistikleri
SELECT JOB_ID, 
       COUNT(*) AS EMPLOYEE_COUNT,
       AVG(SALARY) AS AVG_SALARY,
       MIN(SALARY) AS MIN_SALARY,
       MAX(SALARY) AS MAX_SALARY
FROM HR.EMPLOYEES
GROUP BY JOB_ID
ORDER BY AVG_SALARY DESC;

-- Ãœlke bazÄ±nda lokasyon sayÄ±sÄ±
SELECT COUNTRY_ID, COUNT(*) AS LOCATION_COUNT
FROM HR.LOCATIONS
GROUP BY COUNTRY_ID;
```

### HAVING KoÅŸulu

```sql
-- Ã‡alÄ±ÅŸan sayÄ±sÄ± 5'ten fazla olan departmanlar
SELECT DEPARTMENT_ID, COUNT(*) AS EMPLOYEE_COUNT
FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(*) > 5;

-- Ortalama maaÅŸÄ± 8000'den yÃ¼ksek olan iÅŸ pozisyonlarÄ±
SELECT JOB_ID, AVG(SALARY) AS AVG_SALARY
FROM HR.EMPLOYEES
GROUP BY JOB_ID
HAVING AVG(SALARY) > 8000;

-- Birden fazla Ã§alÄ±ÅŸanÄ± olan ve ortalama maaÅŸÄ± 5000'den yÃ¼ksek departmanlar
SELECT DEPARTMENT_ID, COUNT(*) AS EMP_COUNT, AVG(SALARY) AS AVG_SALARY
FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(*) > 1 AND AVG(SALARY) > 5000;
```

### Ã‡oklu GruplandÄ±rma

```sql
-- Departman ve iÅŸ pozisyonuna gÃ¶re gruplandÄ±rma
SELECT DEPARTMENT_ID, JOB_ID, COUNT(*) AS EMPLOYEE_COUNT, AVG(SALARY) AS AVG_SALARY
FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID, JOB_ID
ORDER BY DEPARTMENT_ID, JOB_ID;

-- YÄ±l ve departmana gÃ¶re iÅŸe alÄ±m sayÄ±sÄ±
SELECT EXTRACT(YEAR FROM HIRE_DATE) AS HIRE_YEAR, 
       DEPARTMENT_ID,
       COUNT(*) AS HIRES
FROM HR.EMPLOYEES
GROUP BY EXTRACT(YEAR FROM HIRE_DATE), DEPARTMENT_ID
ORDER BY HIRE_YEAR, DEPARTMENT_ID;

-- BÃ¶lge bazÄ±nda Ã¼lke ve ÅŸehir sayÄ±sÄ±
SELECT R.REGION_NAME,
       COUNT(DISTINCT C.COUNTRY_ID) AS COUNTRY_COUNT,
       COUNT(DISTINCT L.CITY) AS CITY_COUNT
FROM HR.REGIONS R
JOIN HR.COUNTRIES C ON R.REGION_ID = C.REGION_ID
JOIN HR.LOCATIONS L ON C.COUNTRY_ID = L.COUNTRY_ID
GROUP BY R.REGION_NAME;
```

### Pratik AlÄ±ÅŸtÄ±rma 4
```sql
-- 1. Her departmandaki en yÃ¼ksek, en dÃ¼ÅŸÃ¼k ve ortalama maaÅŸÄ± bulun
SELECT DEPARTMENT_ID,
       MAX(SALARY) AS MAX_SALARY,
       MIN(SALARY) AS MIN_SALARY,
       ROUND(AVG(SALARY), 2) AS AVG_SALARY,
       COUNT(*) AS EMPLOYEE_COUNT
FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID
ORDER BY DEPARTMENT_ID;

-- 2. Komisyon alan Ã§alÄ±ÅŸanlarÄ±n departman bazÄ±nda analizini yapÄ±n
SELECT DEPARTMENT_ID,
       COUNT(*) AS TOTAL_EMPLOYEES,
       COUNT(COMMISSION_PCT) AS EMPLOYEES_WITH_COMMISSION,
       ROUND(AVG(COMMISSION_PCT) * 100, 2) AS AVG_COMMISSION_PCT
FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(COMMISSION_PCT) > 0;

-- 3. Her yÄ±l kaÃ§ kiÅŸinin iÅŸe alÄ±ndÄ±ÄŸÄ±nÄ± bulun
SELECT EXTRACT(YEAR FROM HIRE_DATE) AS HIRE_YEAR,
       COUNT(*) AS NEW_HIRES,
       ROUND(AVG(SALARY), 2) AS AVG_STARTING_SALARY
FROM HR.EMPLOYEES
GROUP BY EXTRACT(YEAR FROM HIRE_DATE)
ORDER BY HIRE_YEAR;

-- 4. Her ÅŸehirde kaÃ§ departman bulunduÄŸunu hesaplayÄ±n
SELECT L.CITY, COUNT(DISTINCT D.DEPARTMENT_ID) AS DEPARTMENT_COUNT
FROM HR.LOCATIONS L
JOIN HR.DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID
GROUP BY L.CITY
ORDER BY DEPARTMENT_COUNT DESC;
```

## ğŸ‹ï¸ **OTURUM 4 - ALIÅTIRMALAR**

### **KOLAY SEVÄ°YE (3 Soru)**

**1. Her iÅŸ pozisyonunda (job_id) kaÃ§ Ã§alÄ±ÅŸan olduÄŸunu listeleyin.**
```sql
-- SORU 1 CEVABI:
SELECT JOB_ID, COUNT(*) AS EMPLOYEE_COUNT
FROM HR.EMPLOYEES
GROUP BY JOB_ID
ORDER BY EMPLOYEE_COUNT DESC;
```

**2. Departman ID'sine gÃ¶re toplam maaÅŸ giderlerini hesaplayÄ±n.**
```sql
-- SORU 2 CEVABI:
SELECT DEPARTMENT_ID, 
       COUNT(*) AS EMP_COUNT,
       SUM(SALARY) AS TOTAL_SALARY_COST
FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID
ORDER BY TOTAL_SALARY_COST DESC;
```

**3. Ã‡alÄ±ÅŸanlarÄ±n iÅŸe baÅŸladÄ±klarÄ± yÄ±la gÃ¶re kaÃ§ kiÅŸi olduÄŸunu bulun.**
```sql
-- SORU 3 CEVABI:
SELECT EXTRACT(YEAR FROM HIRE_DATE) AS HIRE_YEAR,
       COUNT(*) AS HIRED_COUNT
FROM HR.EMPLOYEES
GROUP BY EXTRACT(YEAR FROM HIRE_DATE)
ORDER BY HIRE_YEAR;
```

### **ORTA SEVÄ°YE (3 Soru)**

**4. En az 5 Ã§alÄ±ÅŸanÄ± olan departmanlarÄ±n ortalama maaÅŸlarÄ±nÄ± bulun.**
```sql
-- SORU 4 CEVABI:
SELECT DEPARTMENT_ID,
       COUNT(*) AS EMP_COUNT,
       ROUND(AVG(SALARY), 2) AS AVG_SALARY
FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(*) >= 5
ORDER BY AVG_SALARY DESC;
```

**5. Her ayda kaÃ§ kiÅŸinin iÅŸe baÅŸladÄ±ÄŸÄ±nÄ± bulun (ay ismi ile birlikte).**
```sql
-- SORU 5 CEVABI:
SELECT EXTRACT(MONTH FROM HIRE_DATE) AS MONTH_NUM,
       TO_CHAR(HIRE_DATE, 'MONTH') AS MONTH_NAME,
       COUNT(*) AS HIRED_COUNT
FROM HR.EMPLOYEES
GROUP BY EXTRACT(MONTH FROM HIRE_DATE), TO_CHAR(HIRE_DATE, 'MONTH')
ORDER BY MONTH_NUM;
```

**6. Ortalama maaÅŸÄ± 8000'den yÃ¼ksek olan iÅŸ pozisyonlarÄ±nÄ± listeleyin.**
```sql
-- SORU 6 CEVABI:
SELECT JOB_ID,
       COUNT(*) AS EMP_COUNT,
       ROUND(AVG(SALARY), 2) AS AVG_SALARY,
       MIN(SALARY) AS MIN_SALARY,
       MAX(SALARY) AS MAX_SALARY
FROM HR.EMPLOYEES
GROUP BY JOB_ID
HAVING AVG(SALARY) > 8000
ORDER BY AVG_SALARY DESC;
```

### **ZOR SEVÄ°YE (2 Soru)**

**7. Her departman iÃ§in maaÅŸ daÄŸÄ±lÄ±mÄ±nÄ± analiz edin (standard deviation dahil).**
```sql
-- SORU 7 CEVABI:
SELECT DEPARTMENT_ID,
       COUNT(*) AS EMP_COUNT,
       ROUND(AVG(SALARY), 2) AS AVG_SALARY,
       ROUND(STDDEV(SALARY), 2) AS SALARY_STDDEV,
       MIN(SALARY) AS MIN_SALARY,
       MAX(SALARY) AS MAX_SALARY,
       MAX(SALARY) - MIN(SALARY) AS SALARY_RANGE,
       ROUND((STDDEV(SALARY) / AVG(SALARY)) * 100, 2) AS COEFFICIENT_OF_VARIATION
FROM HR.EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
GROUP BY DEPARTMENT_ID
ORDER BY COEFFICIENT_OF_VARIATION DESC;
```

**8. Ä°ÅŸe alÄ±m trendlerini yÄ±l ve Ã§eyrek bazÄ±nda analiz edin.**
```sql
-- SORU 8 CEVABI:
SELECT EXTRACT(YEAR FROM HIRE_DATE) AS HIRE_YEAR,
       CASE 
           WHEN EXTRACT(MONTH FROM HIRE_DATE) IN (1,2,3) THEN 'Q1'
           WHEN EXTRACT(MONTH FROM HIRE_DATE) IN (4,5,6) THEN 'Q2'
           WHEN EXTRACT(MONTH FROM HIRE_DATE) IN (7,8,9) THEN 'Q3'
           ELSE 'Q4'
       END AS QUARTER,
       COUNT(*) AS HIRES,
       ROUND(AVG(SALARY), 2) AS AVG_STARTING_SALARY,
       COUNT(*) * 100.0 / SUM(COUNT(*)) OVER (PARTITION BY EXTRACT(YEAR FROM HIRE_DATE)) AS PERCENTAGE_OF_YEAR
FROM HR.EMPLOYEES
GROUP BY EXTRACT(YEAR FROM HIRE_DATE),
         CASE 
             WHEN EXTRACT(MONTH FROM HIRE_DATE) IN (1,2,3) THEN 'Q1'
             WHEN EXTRACT(MONTH FROM HIRE_DATE) IN (4,5,6) THEN 'Q2'
             WHEN EXTRACT(MONTH FROM HIRE_DATE) IN (7,8,9) THEN 'Q3'
             ELSE 'Q4'
         END
ORDER BY HIRE_YEAR, QUARTER;
```

---

## **5. OTURUM: Ã‡OKLU TABLO Ä°ÅLEMLERÄ° - JOIN'LER**

# Oracle SQL'de JOIN Ä°ÅŸlemleri - KapsamlÄ± Rehber

Oracle SQL'de **JOIN iÅŸlemleri**, birden fazla tabloyu aralarÄ±ndaki ortak alanlara gÃ¶re birleÅŸtirerek tek bir sorgu sonucu elde etmemizi saÄŸlar.  
AmaÃ§; iliÅŸkisel veritabanÄ±ndaki normalleÅŸtirilmiÅŸ tablolar arasÄ±nda anlamlÄ± veri kÃ¼meleri oluÅŸturmaktÄ±r.  

Oracle'Ä±n **HR (Human Resources)** Ã¶rnek veritabanÄ± bu konuyu anlatmak iÃ§in Ã§ok uygundur Ã§Ã¼nkÃ¼ iÃ§inde `EMPLOYEES`, `DEPARTMENTS`, `LOCATIONS`, `JOBS`, `COUNTRIES` gibi iliÅŸkili tablolar bulunur.

---

## JOIN TÃ¼rleri ve MantÄ±ÄŸÄ±

- **INNER JOIN**: YalnÄ±zca eÅŸleÅŸen kayÄ±tlarÄ± getirir
- **LEFT OUTER JOIN**: Sol tablodaki tÃ¼m kayÄ±tlarÄ± getirir, saÄŸ tabloda eÅŸleÅŸme yoksa NULL dÃ¶ner
- **RIGHT OUTER JOIN**: SaÄŸ tablodaki tÃ¼m kayÄ±tlarÄ± getirir, sol tablodan eÅŸleÅŸmeyenler NULL dÃ¶ner
- **FULL OUTER JOIN**: Hem sol hem saÄŸ tablodaki tÃ¼m kayÄ±tlarÄ± getirir, eÅŸleÅŸmeyenlerde NULL olur
- **CROSS JOIN**: Kartesyen Ã§arpÄ±m (tÃ¼m kayÄ±tlarÄ±n kombinasyonu)
- **SELF JOIN**: Bir tablonun kendi kendisiyle join edilmesi

---

## LEFT ve RIGHT JOIN'de Sol/SaÄŸ Tablo MantÄ±ÄŸÄ±

**Sol** ve **saÄŸ** tablolar, tamamen sorguda tablolarÄ± hangi sÄ±rada yazdÄ±ÄŸÄ±na gÃ¶re belirlenir:

- **LEFT JOIN**: `FROM` ifadesinde Ã¶nce yazÄ±lan tablo **sol tablo**, `JOIN` ile baÄŸlanan tablo **saÄŸ tablo**dur  
  â†’ Sol tablodaki tÃ¼m kayÄ±tlar gelir, saÄŸda eÅŸleÅŸmeyenler `NULL` olur

- **RIGHT JOIN**: `JOIN` kelimesinden Ã¶nce yazÄ±lan tablo **sol tablo**, `JOIN`den sonra yazÄ±lan tablo **saÄŸ tablo**dur  
  â†’ SaÄŸ tablodaki tÃ¼m kayÄ±tlar gelir, solda eÅŸleÅŸmeyenler `NULL` olur

> **Not:** Bir LEFT JOIN, tablolarÄ±n yerini deÄŸiÅŸtirip RIGHT JOIN olarak da yazÄ±labilir. Yani ikisi arasÄ±nda mantÄ±ksal bir eÅŸdeÄŸerlik vardÄ±r.

---

## HR VeritabanÄ± Ãœzerinden Ã–rnekler

### 1. INNER JOIN  
Ã‡alÄ±ÅŸanlarÄ±n hangi departmanda Ã§alÄ±ÅŸtÄ±ÄŸÄ±nÄ± listeleyelim:

```sql
SELECT e.first_name, e.last_name, d.department_name
FROM hr.employees e
INNER JOIN hr.departments d 
  ON e.department_id = d.department_id;
```
ğŸ”¹ Burada sadece **departmanÄ± olan Ã§alÄ±ÅŸanlar** gelir.

---

### 2. LEFT OUTER JOIN

DepartmanÄ± olmayan Ã§alÄ±ÅŸanlarÄ± da gÃ¶rmek iÃ§in LEFT JOIN kullanÄ±rÄ±z:

```sql
SELECT e.first_name, e.last_name, d.department_name
FROM hr.employees e
LEFT JOIN hr.departments d
  ON e.department_id = d.department_id;
```

**AÃ§Ä±klama:**
- **Sol tablo:** employees
- **SaÄŸ tablo:** departments
- EÄŸer Ã§alÄ±ÅŸanÄ±n `department_id`'si yoksa, `department_name` NULL dÃ¶ner
- Sol tablodaki tÃ¼m kayÄ±tlar muhafaza edilir

---

### 3. RIGHT OUTER JOIN

TÃ¼m departmanlarÄ± listelemek iÃ§in, Ã§alÄ±ÅŸan yoksa boÅŸ kalacak ÅŸekilde RIGHT JOIN kullanÄ±rÄ±z:

```sql
SELECT e.first_name, e.last_name, d.department_name
FROM hr.employees e
RIGHT JOIN hr.departments d
  ON e.department_id = d.department_id;
```

**AÃ§Ä±klama:**
- **Sol tablo:** employees
- **SaÄŸ tablo:** departments
- HiÃ§ Ã§alÄ±ÅŸanÄ± olmayan departmanlar da sonuÃ§ta gÃ¶rÃ¼nÃ¼r
- SaÄŸ tablodaki tÃ¼m kayÄ±tlar muhafaza edilir

---

### 4. FULL OUTER JOIN

Hem boÅŸ departmanlarÄ± hem de departmanÄ± olmayan Ã§alÄ±ÅŸanlarÄ± gÃ¶rmek iÃ§in FULL OUTER JOIN kullanÄ±rÄ±z:

```sql
SELECT e.first_name, e.last_name, d.department_name
FROM hr.employees e
FULL OUTER JOIN hr.departments d
  ON e.department_id = d.department_id;
```

**AÃ§Ä±klama:**
- Her iki tablodaki tÃ¼m kayÄ±tlar muhafaza edilir
- EÅŸleÅŸmeyen kayÄ±tlar iÃ§in NULL deÄŸerler dÃ¶ner
- LEFT JOIN + RIGHT JOIN'in birleÅŸimi gibi Ã§alÄ±ÅŸÄ±r

---

### 5. CROSS JOIN

TÃ¼m Ã§alÄ±ÅŸanlar ile tÃ¼m departmanlarÄ±n kombinasyonunu gÃ¶rmek iÃ§in:

```sql
SELECT e.first_name, e.last_name, d.department_name
FROM hr.employees e
CROSS JOIN hr.departments d;
```

**AÃ§Ä±klama:**
- Her Ã§alÄ±ÅŸan, her departman ile eÅŸleÅŸtirilir
- EÄŸer 100 Ã§alÄ±ÅŸan ve 10 departman varsa, 1000 satÄ±r dÃ¶ner
- **Dikkat:** Ã‡ok bÃ¼yÃ¼k sonuÃ§ kÃ¼meleri oluÅŸabilir, gerÃ§ek projĞµĞ»erde dikkatli kullanÄ±lmalÄ±dÄ±r

---

### 6. SELF JOIN  

**SELF JOIN**, bir tablonun **kendi kendisiyle join** edilmesidir.  
HR veritabanÄ±nda Ã§alÄ±ÅŸan ile yÃ¶neticisini bulmak iÃ§in:

```sql
SELECT e.first_name AS employee_name,
       m.first_name AS manager_name
FROM hr.employees e
LEFT JOIN hr.employees m
  ON e.manager_id = m.employee_id;
```

ğŸ”¹ Burada `employees` tablosu hem Ã§alÄ±ÅŸan hem yÃ¶netici bilgisi iÃ§in kullanÄ±lÄ±r.

---

### 7. Zincirleme JOIN Ä°ÅŸlemleri  

Ã‡alÄ±ÅŸanlarÄ±n Ã¼lke bilgilerini bulalÄ±m (`employees â†’ departments â†’ locations â†’ countries` zinciri):

```sql
SELECT e.first_name, e.last_name, d.department_name, l.city, c.country_name
FROM hr.employees e
INNER JOIN hr.departments d   ON e.department_id = d.department_id
INNER JOIN hr.locations l     ON d.location_id = l.location_id
INNER JOIN hr.countries c     ON l.country_id = c.country_id;
```

ğŸ”¹ Bu sorguda Ã§alÄ±ÅŸan â†’ departman â†’ ÅŸehir â†’ Ã¼lke zincirleme join ile baÄŸlanÄ±r.

---

## WHERE vs ON FarkÄ±

**ON:** JOIN koÅŸulunu belirtir (tablolar arasÄ± iliÅŸki)  
**WHERE:** JOIN sonrasÄ± filtreleme yapar

```sql
-- YANLIÅ kullanÄ±m
SELECT e.first_name, d.department_name
FROM hr.employees e
LEFT JOIN hr.departments d
  ON e.department_id = d.department_id
  AND d.department_name = 'IT';  -- Bu ON'da olmamalÄ±

-- DOÄRU kullanÄ±m
SELECT e.first_name, d.department_name
FROM hr.employees e
LEFT JOIN hr.departments d
  ON e.department_id = d.department_id
WHERE d.department_name = 'IT';  -- Bu WHERE'de olmalÄ±
```

---

## Performans Ä°puÃ§larÄ±

### JOIN SÄ±ralamasÄ±
- **KÃ¼Ã§Ã¼k tablolarÄ± Ã¶nce** join edin
- **En seÃ§ici koÅŸullarÄ±** Ã¶nce yazÄ±n
- **Ä°ndeksli kolonlar** Ã¼zerinden join yapÄ±n

### Performans KarÅŸÄ±laÅŸtÄ±rmasÄ±
| JOIN TÃ¼rÃ¼ | Performans | AÃ§Ä±klama |
|-----------|------------|----------|
| **INNER JOIN** | â­â­â­â­â­ | En hÄ±zlÄ±, sadece eÅŸleÅŸenleri getirir |
| **LEFT/RIGHT JOIN** | â­â­â­â­ | Orta hÄ±zlÄ±, NULL kontrolÃ¼ gerekir |
| **FULL OUTER JOIN** | â­â­â­ | YavaÅŸ, her iki tarafÄ± da kontrol eder |
| **CROSS JOIN** | â­ | En yavaÅŸ, kartesyen Ã§arpÄ±m |

---

## Pratik AlÄ±ÅŸtÄ±rmalar

### Soru 1
**HR veritabanÄ±nda, tÃ¼m Ã§alÄ±ÅŸanlarÄ±n isimlerini, maaÅŸlarÄ±nÄ± ve departman isimlerini listeleyin. DepartmanÄ± olmayan Ã§alÄ±ÅŸanlar da gÃ¶rÃ¼nmelidir.**

<details>
<summary>Ã‡Ã¶zÃ¼mÃ¼ gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

```sql
SELECT e.first_name, e.last_name, e.salary, d.department_name
FROM hr.employees e
LEFT JOIN hr.departments d
  ON e.department_id = d.department_id;
```

**AÃ§Ä±klama:** LEFT JOIN kullanÄ±yoruz Ã§Ã¼nkÃ¼ tÃ¼m Ã§alÄ±ÅŸanlarÄ± (departmanÄ± olmayan dahil) gÃ¶rmek istiyoruz.
</details>

---

### Soru 2
**Hangi departmanlarda hiÃ§ Ã§alÄ±ÅŸan yoktur? Bu departmanlarÄ± listeleyin.**

<details>
<summary>Ã‡Ã¶zÃ¼mÃ¼ gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

```sql
SELECT d.department_name
FROM hr.departments d
LEFT JOIN hr.employees e
  ON d.department_id = e.department_id
WHERE e.employee_id IS NULL;
```

**AÃ§Ä±klama:** RIGHT JOIN yerine LEFT JOIN kullanÄ±p WHERE ile NULL kontrolÃ¼ yapÄ±yoruz.
</details>

---

### Soru 3
**Her Ã§alÄ±ÅŸanÄ±n ismini, yÃ¶neticisinin ismini ve departman ismini gÃ¶sterin.**

<details>
<summary>Ã‡Ã¶zÃ¼mÃ¼ gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

```sql
SELECT e.first_name AS employee_name,
       m.first_name AS manager_name,
       d.department_name
FROM hr.employees e
LEFT JOIN hr.employees m        ON e.manager_id = m.employee_id
LEFT JOIN hr.departments d      ON e.department_id = d.department_id;
```

**AÃ§Ä±klama:** SELF JOIN (e ve m) ile yÃ¶netici bilgisini, normal JOIN ile departman bilgisini alÄ±yoruz.
</details>

---

### Soru 4
**Ä°ngiltere'de (United Kingdom) Ã§alÄ±ÅŸan personellerin isimlerini ve ÅŸehirlerini listeleyin.**

<details>
<summary>Ã‡Ã¶zÃ¼mÃ¼ gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

```sql
SELECT e.first_name, e.last_name, l.city
FROM hr.employees e
INNER JOIN hr.departments d     ON e.department_id = d.department_id
INNER JOIN hr.locations l       ON d.location_id = l.location_id
INNER JOIN hr.countries c       ON l.country_id = c.country_id
WHERE c.country_name = 'United Kingdom';
```

**AÃ§Ä±klama:** Zincirleme JOIN ile employees â†’ departments â†’ locations â†’ countries baÄŸlantÄ±sÄ±nÄ± kuruyoruz.
</details>

---

### Soru 5
**MaaÅŸÄ± 10000'den fazla olan Ã§alÄ±ÅŸanlarÄ±n isimlerini, maaÅŸlarÄ±nÄ± ve iÅŸ Ã¼nvanlarÄ±nÄ± (job_title) gÃ¶sterin.**

<details>
<summary>Ã‡Ã¶zÃ¼mÃ¼ gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

```sql
SELECT e.first_name, e.last_name, e.salary, j.job_title
FROM hr.employees e
INNER JOIN hr.jobs j
  ON e.job_id = j.job_id
WHERE e.salary > 10000;
```

**AÃ§Ä±klama:** employees ve jobs tablolarÄ±nÄ± job_id Ã¼zerinden join edip WHERE ile maaÅŸ filtresi uyguluyoruz.
</details>

---

## Ã–zet Tablosu

| JOIN TÃ¼rÃ¼ | Ne Getirir? | KullanÄ±m AlanÄ± |
|-----------|-------------|----------------|
| **INNER JOIN** | Sadece eÅŸleÅŸenler | Standart raporlar |
| **LEFT JOIN** | Sol tablo + eÅŸleÅŸenler | Eksik verileri de gÃ¶rmek |
| **RIGHT JOIN** | SaÄŸ tablo + eÅŸleÅŸenler | Referans tablolarÄ±n tamamÄ± |
| **FULL OUTER JOIN** | Her iki taraf da | Veri analizi, tutarsÄ±zlÄ±k tespiti |
| **CROSS JOIN** | TÃ¼m kombinasyonlar | Test verileri, matrix oluÅŸturma |
| **SELF JOIN** | AynÄ± tablonun kendisiyle | HiyerarÅŸik veriler |

---

## Son Tavsiyeler

1. **Her zaman uygun JOIN tÃ¼rÃ¼nÃ¼ seÃ§in** - gereksiz veri getirmeyin
2. **Alias kullanÄ±n** (`e`, `d` gibi) - kod okunabilirliÄŸi iÃ§in
3. **WHERE ve ON'u doÄŸru yerde kullanÄ±n** - performans iÃ§in kritik
4. **Ä°ndeksleri kontrol edin** - JOIN kolonlarÄ± indeksli olmalÄ±
5. **KÃ¼Ã§Ã¼k tablolardan baÅŸlayÄ±n** - sÄ±rala performans iÃ§in Ã¶nemli

> **HatÄ±rlatma:** Bu Ã¶rneklerde `hr.employees`, `hr.departments` vb. tablolar Oracle HR ÅŸemasÄ± kullanÄ±larak yazÄ±lmÄ±ÅŸtÄ±r. Kendi veritabanÄ±nÄ±zda tablo isimlerini uygun ÅŸekilde deÄŸiÅŸtirin.


### 5. JOIN ile Daha KarmaÅŸÄ±k Ä°liÅŸkiler  
Ã‡alÄ±ÅŸanlarÄ±n Ã¼lke bilgilerini bulalÄ±m (`employees â†’ departments â†’ locations â†’ countries` zinciri):
```sql
SELECT e.first_name, e.last_name, d.department_name, l.city, c.country_name
FROM employees e
JOIN departments d   ON e.department_id = d.department_id
JOIN locations l     ON d.location_id = l.location_id
JOIN countries c     ON l.country_id = c.country_id;
```
ğŸ”¹ Bu sorguda Ã§alÄ±ÅŸan â†’ departman â†’ ÅŸehir â†’ Ã¼lke zincirleme join ile baÄŸlanÄ±r.

---

## Ã–zet

- **INNER JOIN**: YalnÄ±zca eÅŸleÅŸenler  
- **LEFT JOIN**: Sol tablo baskÄ±n  
- **RIGHT JOIN**: SaÄŸ tablo baskÄ±n  
- **FULL OUTER JOIN**: Her iki taraf da baskÄ±n  
- **CROSS JOIN**: TÃ¼m kombinasyonlar  

### INNER JOIN

```sql
-- Ã‡alÄ±ÅŸanlar ve departman bilgileri
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME
FROM HR.EMPLOYEES E
INNER JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;

-- Ã‡alÄ±ÅŸanlar ve iÅŸ pozisyon bilgileri
SELECT E.FIRST_NAME, E.LAST_NAME, J.JOB_TITLE, E.SALARY
FROM HR.EMPLOYEES E
INNER JOIN HR.JOBS J ON E.JOB_ID = J.JOB_ID;

-- ÃœÃ§lÃ¼ JOIN: Ã‡alÄ±ÅŸan, departman ve lokasyon
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME, L.CITY
FROM HR.EMPLOYEES E
INNER JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
INNER JOIN HR.LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID;

-- DÃ¶rtlÃ¼ JOIN: Ã‡alÄ±ÅŸan, departman, lokasyon ve Ã¼lke
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME
FROM HR.EMPLOYEES E
INNER JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
INNER JOIN HR.LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
INNER JOIN HR.COUNTRIES C ON L.COUNTRY_ID = C.COUNTRY_ID;
```

### LEFT OUTER JOIN

```sql
-- TÃ¼m departmanlar ve Ã§alÄ±ÅŸan sayÄ±larÄ± (Ã§alÄ±ÅŸanÄ± olmayan departmanlar dahil)
SELECT D.DEPARTMENT_NAME, COUNT(E.EMPLOYEE_ID) AS EMPLOYEE_COUNT
FROM HR.DEPARTMENTS D
LEFT JOIN HR.EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME
ORDER BY EMPLOYEE_COUNT DESC;

-- TÃ¼m Ã§alÄ±ÅŸanlar ve yÃ¶netici bilgileri
SELECT E.FIRST_NAME || ' ' || E.LAST_NAME AS EMPLOYEE,
       M.FIRST_NAME || ' ' || M.LAST_NAME AS MANAGER
FROM HR.EMPLOYEES E
LEFT JOIN HR.EMPLOYEES M ON E.MANAGER_ID = M.EMPLOYEE_ID;

-- TÃ¼m Ã¼lkeler ve lokasyon sayÄ±larÄ±
SELECT C.COUNTRY_NAME, COUNT(L.LOCATION_ID) AS LOCATION_COUNT
FROM HR.COUNTRIES C
LEFT JOIN HR.LOCATIONS L ON C.COUNTRY_ID = L.COUNTRY_ID
GROUP BY C.COUNTRY_NAME
ORDER BY LOCATION_COUNT DESC;
```

### RIGHT OUTER JOIN

```sql
-- SaÄŸ tablodan tÃ¼m kayÄ±tlarÄ± almak iÃ§in
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME
FROM HR.EMPLOYEES E
RIGHT JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
```

### FULL OUTER JOIN

```sql
-- Her iki tablodaki tÃ¼m kayÄ±tlarÄ± almak iÃ§in
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME
FROM HR.EMPLOYEES E
FULL OUTER JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
```

### SELF JOIN

```sql
-- Ã‡alÄ±ÅŸan ve yÃ¶neticilerini listele
SELECT EMP.FIRST_NAME || ' ' || EMP.LAST_NAME AS EMPLOYEE,
       MGR.FIRST_NAME || ' ' || MGR.LAST_NAME AS MANAGER
FROM HR.EMPLOYEES EMP
JOIN HR.EMPLOYEES MGR ON EMP.MANAGER_ID = MGR.EMPLOYEE_ID;

-- AynÄ± departmandaki Ã§alÄ±ÅŸan Ã§iftleri
SELECT E1.FIRST_NAME || ' ' || E1.LAST_NAME AS EMPLOYEE1,
       E2.FIRST_NAME || ' ' || E2.LAST_NAME AS EMPLOYEE2,
       E1.DEPARTMENT_ID
FROM HR.EMPLOYEES E1
JOIN HR.EMPLOYEES E2 ON E1.DEPARTMENT_ID = E2.DEPARTMENT_ID
WHERE E1.EMPLOYEE_ID < E2.EMPLOYEE_ID;

-- AynÄ± iÅŸi yapan Ã§alÄ±ÅŸanlarÄ± karÅŸÄ±laÅŸtÄ±r
SELECT E1.FIRST_NAME || ' ' || E1.LAST_NAME AS EMPLOYEE1,
       E2.FIRST_NAME || ' ' || E2.LAST_NAME AS EMPLOYEE2,
       E1.JOB_ID,
       E1.SALARY AS SALARY1,
       E2.SALARY AS SALARY2
FROM HR.EMPLOYEES E1
JOIN HR.EMPLOYEES E2 ON E1.JOB_ID = E2.JOB_ID
WHERE E1.EMPLOYEE_ID < E2.EMPLOYEE_ID;
```

### Kompleks JOIN Ã–rnekleri

```sql
-- Departman yÃ¶neticileri ve Ã§alÄ±ÅŸan sayÄ±larÄ±
SELECT D.DEPARTMENT_NAME,
       M.FIRST_NAME || ' ' || M.LAST_NAME AS MANAGER_NAME,
       COUNT(E.EMPLOYEE_ID) AS EMPLOYEE_COUNT
FROM HR.DEPARTMENTS D
JOIN HR.EMPLOYEES M ON D.MANAGER_ID = M.EMPLOYEE_ID
LEFT JOIN HR.EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME, M.FIRST_NAME, M.LAST_NAME;

-- Ãœlke, bÃ¶lge, ÅŸehir, departman ve Ã§alÄ±ÅŸan bilgileri
SELECT R.REGION_NAME, C.COUNTRY_NAME, L.CITY, D.DEPARTMENT_NAME, 
       COUNT(E.EMPLOYEE_ID) AS EMPLOYEE_COUNT
FROM HR.REGIONS R
JOIN HR.COUNTRIES C ON R.REGION_ID = C.REGION_ID
JOIN HR.LOCATIONS L ON C.COUNTRY_ID = L.COUNTRY_ID
JOIN HR.DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID
LEFT JOIN HR.EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY R.REGION_NAME, C.COUNTRY_NAME, L.CITY, D.DEPARTMENT_NAME
ORDER BY R.REGION_NAME, C.COUNTRY_NAME, L.CITY;

-- Ã‡alÄ±ÅŸanlarÄ±n iÅŸ geÃ§miÅŸi analizi
SELECT E.FIRST_NAME, E.LAST_NAME,
       JH.START_DATE, JH.END_DATE,
       J.JOB_TITLE AS PREVIOUS_JOB,
       D.DEPARTMENT_NAME AS PREVIOUS_DEPT,
       MONTHS_BETWEEN(JH.END_DATE, JH.START_DATE) AS MONTHS_IN_POSITION
FROM HR.EMPLOYEES E
JOIN HR.JOB_HISTORY JH ON E.EMPLOYEE_ID = JH.EMPLOYEE_ID
JOIN HR.JOBS J ON JH.JOB_ID = J.JOB_ID
JOIN HR.DEPARTMENTS D ON JH.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY E.LAST_NAME, JH.START_DATE;
```

### Pratik AlÄ±ÅŸtÄ±rma 5
```sql
-- 1. Her Ã§alÄ±ÅŸanÄ±n adÄ±, soyadÄ±, departman adÄ±, ÅŸehir ve Ã¼lke bilgilerini listeleyin
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME
FROM HR.EMPLOYEES E
JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN HR.LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
JOIN HR.COUNTRIES C ON L.COUNTRY_ID = C.COUNTRY_ID;

-- 2. Her departmandaki Ã§alÄ±ÅŸan sayÄ±sÄ±nÄ± ve ortalama maaÅŸÄ± departman adÄ±yla birlikte gÃ¶sterin
SELECT D.DEPARTMENT_NAME,
       COUNT(E.EMPLOYEE_ID) AS EMPLOYEE_COUNT,
       ROUND(AVG(E.SALARY), 2) AS AVG_SALARY,
       L.CITY
FROM HR.DEPARTMENTS D
LEFT JOIN HR.EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
LEFT JOIN HR.LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
GROUP BY D.DEPARTMENT_NAME, L.CITY
ORDER BY EMPLOYEE_COUNT DESC;

-- 3. En yÃ¼ksek maaÅŸlÄ± Ã§alÄ±ÅŸanÄ±n bilgilerini departman, ÅŸehir ve iÅŸ unvanÄ±yla birlikte gÃ¶sterin
SELECT E.FIRST_NAME, E.LAST_NAME, E.SALARY, D.DEPARTMENT_NAME, J.JOB_TITLE, L.CITY
FROM HR.EMPLOYEES E
JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN HR.JOBS J ON E.JOB_ID = J.JOB_ID
JOIN HR.LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.SALARY = (SELECT MAX(SALARY) FROM HR.EMPLOYEES);

-- 4. Her bÃ¶lgedeki toplam Ã§alÄ±ÅŸan sayÄ±sÄ±nÄ± hesaplayÄ±n
SELECT R.REGION_NAME, COUNT(E.EMPLOYEE_ID) AS TOTAL_EMPLOYEES
FROM HR.REGIONS R
JOIN HR.COUNTRIES C ON R.REGION_ID = C.REGION_ID
JOIN HR.LOCATIONS L ON C.COUNTRY_ID = L.COUNTRY_ID
JOIN HR.DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID
LEFT JOIN HR.EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY R.REGION_NAME
ORDER BY TOTAL_EMPLOYEES DESC;
```

## ğŸ‹ï¸ **OTURUM 5 - ALIÅTIRMALAR**

### **KOLAY SEVÄ°YE (3 Soru)**

**1. Ã‡alÄ±ÅŸanlarÄ± departman adlarÄ± ve iÅŸ unvanlarÄ± ile birlikte listeleyin.**
```sql
-- SORU 1 CEVABI:
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME, J.JOB_TITLE
FROM HR.EMPLOYEES E
JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN HR.JOBS J ON E.JOB_ID = J.JOB_ID
ORDER BY D.DEPARTMENT_NAME, E.LAST_NAME;
```

**2. Hangi ÅŸehirlerde departmanlar bulunduÄŸunu listeleyin.**
```sql
-- SORU 2 CEVABI:
SELECT DISTINCT L.CITY, C.COUNTRY_NAME
FROM HR.LOCATIONS L
JOIN HR.COUNTRIES C ON L.COUNTRY_ID = C.COUNTRY_ID
JOIN HR.DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID
ORDER BY C.COUNTRY_NAME, L.CITY;
```

**3. Ã‡alÄ±ÅŸanlarÄ± yÃ¶neticileri ile birlikte listeleyin.**
```sql
-- SORU 3 CEVABI:
SELECT E.FIRST_NAME || ' ' || E.LAST_NAME AS EMPLOYEE,
       M.FIRST_NAME || ' ' || M.LAST_NAME AS MANAGER
FROM HR.EMPLOYEES E
LEFT JOIN HR.EMPLOYEES M ON E.MANAGER_ID = M.EMPLOYEE_ID
ORDER BY M.LAST_NAME NULLS FIRST, E.LAST_NAME;
```

### **ORTA SEVÄ°YE (3 Soru)**

**4. Her Ã¼lkedeki departman sayÄ±sÄ±nÄ± ve toplam Ã§alÄ±ÅŸan sayÄ±sÄ±nÄ± gÃ¶sterin.**
```sql
-- SORU 4 CEVABI:
SELECT C.COUNTRY_NAME,
       COUNT(DISTINCT D.DEPARTMENT_ID) AS DEPT_COUNT,
       COUNT(E.EMPLOYEE_ID) AS TOTAL_EMPLOYEES
FROM HR.COUNTRIES C
JOIN HR.LOCATIONS L ON C.COUNTRY_ID = L.COUNTRY_ID
JOIN HR.DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID
LEFT JOIN HR.EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY C.COUNTRY_NAME
ORDER BY TOTAL_EMPLOYEES DESC;
```

**5. MaaÅŸ aralÄ±ÄŸÄ± (MIN_SALARY - MAX_SALARY) ile Ã§alÄ±ÅŸanlarÄ±n gerÃ§ek maaÅŸlarÄ±nÄ± karÅŸÄ±laÅŸtÄ±rÄ±n.**
```sql
-- SORU 5 CEVABI:
SELECT E.FIRST_NAME, E.LAST_NAME, E.SALARY, J.JOB_TITLE,
       J.MIN_SALARY, J.MAX_SALARY,
       E.SALARY - J.MIN_SALARY AS ABOVE_MIN,
       J.MAX_SALARY - E.SALARY AS BELOW_MAX,
       ROUND((E.SALARY - J.MIN_SALARY) / (J.MAX_SALARY - J.MIN_SALARY) * 100, 1) AS SALARY_PERCENTAGE
FROM HR.EMPLOYEES E
JOIN HR.JOBS J ON E.JOB_ID = J.JOB_ID
ORDER BY SALARY_PERCENTAGE DESC;
```

**6. Ä°ÅŸ geÃ§miÅŸi olan Ã§alÄ±ÅŸanlarÄ±n mevcut ve Ã¶nceki pozisyonlarÄ±nÄ± karÅŸÄ±laÅŸtÄ±rÄ±n.**
```sql
-- SORU 6 CEVABI:
SELECT E.FIRST_NAME, E.LAST_NAME,
       CJ.JOB_TITLE AS CURRENT_JOB,
       PJ.JOB_TITLE AS PREVIOUS_JOB,
       JH.START_DATE AS PREVIOUS_START,
       JH.END_DATE AS PREVIOUS_END
FROM HR.EMPLOYEES E
JOIN HR.JOBS CJ ON E.JOB_ID = CJ.JOB_ID
JOIN HR.JOB_HISTORY JH ON E.EMPLOYEE_ID = JH.EMPLOYEE_ID
JOIN HR.JOBS PJ ON JH.JOB_ID = PJ.JOB_ID
ORDER BY E.LAST_NAME, JH.START_DATE;
```

### **ZOR SEVÄ°YE (2 Soru)**

**7. Her departman yÃ¶neticisinin yÃ¶nettiÄŸi Ã§alÄ±ÅŸan sayÄ±sÄ±nÄ± ve bu Ã§alÄ±ÅŸanlarÄ±n ortalama maaÅŸÄ±nÄ± hesaplayÄ±n.**
```sql
-- SORU 7 CEVABI:
SELECT MGR.FIRST_NAME || ' ' || MGR.LAST_NAME AS MANAGER_NAME,
       D.DEPARTMENT_NAME,
       COUNT(EMP.EMPLOYEE_ID) AS DIRECT_REPORTS,
       ROUND(AVG(EMP.SALARY), 2) AS AVG_SUBORDINATE_SALARY,
       MGR.SALARY AS MANAGER_SALARY,
       ROUND(MGR.SALARY / AVG(EMP.SALARY), 2) AS SALARY_RATIO
FROM HR.EMPLOYEES MGR
JOIN HR.DEPARTMENTS D ON MGR.EMPLOYEE_ID = D.MANAGER_ID
LEFT JOIN HR.EMPLOYEES EMP ON MGR.EMPLOYEE_ID = EMP.MANAGER_ID
GROUP BY MGR.FIRST_NAME, MGR.LAST_NAME, D.DEPARTMENT_NAME, MGR.SALARY
ORDER BY DIRECT_REPORTS DESC;
```

**8. CoÄŸrafi daÄŸÄ±lÄ±m analizi: Hangi bÃ¶lgede hangi iÅŸ pozisyonlarÄ±ndan kaÃ§ kiÅŸi Ã§alÄ±ÅŸÄ±yor?**
```sql
-- SORU 8 CEVABI:
SELECT R.REGION_NAME, C.COUNTRY_NAME, L.CITY, J.JOB_TITLE,
       COUNT(E.EMPLOYEE_ID) AS EMPLOYEE_COUNT,
       ROUND(AVG(E.SALARY), 2) AS AVG_SALARY,
       COUNT(E.EMPLOYEE_ID) * 100.0 / SUM(COUNT(E.EMPLOYEE_ID)) OVER (PARTITION BY R.REGION_NAME) AS REGION_PERCENTAGE
FROM HR.REGIONS R
JOIN HR.COUNTRIES C ON R.REGION_ID = C.REGION_ID
JOIN HR.LOCATIONS L ON C.COUNTRY_ID = L.COUNTRY_ID
JOIN HR.DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID
JOIN HR.EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
JOIN HR.JOBS J ON E.JOB_ID = J.JOB_ID
GROUP BY R.REGION_NAME, C.COUNTRY_NAME, L.CITY, J.JOB_TITLE
ORDER BY R.REGION_NAME, EMPLOYEE_COUNT DESC;
```

---

## **6. OTURUM: ALT SORGULAR (SUBQUERIES)**


# Oracle SQL'de SubQuery Ä°ÅŸlemleri - KapsamlÄ± Rehber

**SubQuery (Alt Sorgu)**, bir SQL sorgusunun iÃ§inde bulunan baÅŸka bir SQL sorgusudur. Ana sorguya veri saÄŸlamak, filtreleme yapmak veya hesaplama iÃ§in kullanÄ±lÄ±r. SubQuery'ler Oracle SQL'de Ã§ok gÃ¼Ã§lÃ¼ bir araÃ§tÄ±r ve karmaÅŸÄ±k veri analizlerini tek sorguda yapmamÄ±zÄ± saÄŸlar.

Oracle'Ä±n **HR (Human Resources)** Ã¶rnek veritabanÄ±nÄ± kullanarak SubQuery tÃ¼rlerini ve kullanÄ±m alanlarÄ±nÄ± detaylÄ± olarak inceleyeceÄŸiz.

---

## SubQuery TÃ¼rleri

### Konuma GÃ¶re SÄ±nÄ±flandÄ±rma
- **SELECT SubQuery**: SELECT ifadesinde kullanÄ±lan
- **WHERE SubQuery**: WHERE koÅŸulunda kullanÄ±lan  
- **FROM SubQuery**: FROM clause'unda kullanÄ±lan (Inline View)
- **HAVING SubQuery**: HAVING koÅŸulunda kullanÄ±lan

### Sonuca GÃ¶re SÄ±nÄ±flandÄ±rma
- **Single Row SubQuery**: Tek satÄ±r dÃ¶nen (=, >, <, >=, <=, <> operatÃ¶rleri)
- **Multiple Row SubQuery**: Ã‡ok satÄ±r dÃ¶nen (IN, ANY, ALL operatÃ¶rleri)
- **Multiple Column SubQuery**: Ã‡ok kolon dÃ¶nen
- **Correlated SubQuery**: Ana sorguya baÄŸÄ±mlÄ± olan

---

## 1. Single Row SubQuery

Tek bir deÄŸer dÃ¶nen alt sorgulardÄ±r. =, >, <, >=, <=, <> operatÃ¶rleri ile kullanÄ±lÄ±r.

### Ã–rnek 1: En YÃ¼ksek MaaÅŸlÄ± Ã‡alÄ±ÅŸan
```sql
SELECT first_name, last_name, salary
FROM hr.employees
WHERE salary = (SELECT MAX(salary) FROM hr.employees);
```
ğŸ”¹ **AÃ§Ä±klama:** Alt sorgu tek bir deÄŸer (maksimum maaÅŸ) dÃ¶ner, ana sorgu bu deÄŸere eÅŸit Ã§alÄ±ÅŸanlarÄ± bulur.

### Ã–rnek 2: Ortalama MaaÅŸÄ±n ÃœstÃ¼ndeki Ã‡alÄ±ÅŸanlar
```sql
SELECT first_name, last_name, salary
FROM hr.employees
WHERE salary > (SELECT AVG(salary) FROM hr.employees);
```

### Ã–rnek 3: Belirli Bir DepartmanÄ±n Ortalama MaaÅŸÄ±ndan Fazla Kazananlar
```sql
SELECT first_name, last_name, salary, department_id
FROM hr.employees
WHERE salary > (
    SELECT AVG(salary) 
    FROM hr.employees 
    WHERE department_id = 50
);
```

---

## 2. Multiple Row SubQuery

Birden fazla satÄ±r dÃ¶nen alt sorgulardÄ±r. IN, ANY, ALL operatÃ¶rleri ile kullanÄ±lÄ±r.

### IN OperatÃ¶rÃ¼
```sql
-- IT ve Finance departmanlarÄ±ndaki Ã§alÄ±ÅŸanlar
SELECT first_name, last_name, department_id
FROM hr.employees
WHERE department_id IN (
    SELECT department_id 
    FROM hr.departments 
    WHERE department_name IN ('IT', 'Finance')
);
```

### ANY OperatÃ¶rÃ¼  
```sql
-- Herhangi bir departmanÄ±n minimum maaÅŸÄ±ndan fazla kazanan Ã§alÄ±ÅŸanlar
SELECT first_name, last_name, salary
FROM hr.employees
WHERE salary > ANY (
    SELECT MIN(salary) 
    FROM hr.employees 
    GROUP BY department_id
);
```

### ALL OperatÃ¶rÃ¼
```sql
-- TÃ¼m departmanlarÄ±n maksimum maaÅŸÄ±ndan fazla kazanan Ã§alÄ±ÅŸanlar
SELECT first_name, last_name, salary
FROM hr.employees
WHERE salary > ALL (
    SELECT MAX(salary) 
    FROM hr.employees 
    GROUP BY department_id
);
```

---

## 3. Multiple Column SubQuery

Birden fazla kolon deÄŸeri dÃ¶nen alt sorgulardÄ±r.

```sql
-- Her departmanÄ±n en dÃ¼ÅŸÃ¼k maaÅŸlÄ± Ã§alÄ±ÅŸanlarÄ±
SELECT first_name, last_name, salary, department_id
FROM hr.employees
WHERE (salary, department_id) IN (
    SELECT MIN(salary), department_id
    FROM hr.employees
    GROUP BY department_id
);
```

---

## 4. Correlated SubQuery (Ä°liÅŸkili Alt Sorgu)

Ana sorgunun her satÄ±rÄ± iÃ§in alt sorgu tekrar Ã§alÄ±ÅŸÄ±r. Ana sorgudan gelen deÄŸerleri kullanÄ±r.

### Ã–rnek 1: Kendi DepartmanÄ±nÄ±n OrtalamasÄ±ndan Fazla Kazananlar
```sql
SELECT e1.first_name, e1.last_name, e1.salary, e1.department_id
FROM hr.employees e1
WHERE e1.salary > (
    SELECT AVG(e2.salary)
    FROM hr.employees e2
    WHERE e2.department_id = e1.department_id
);
```

### Ã–rnek 2: EXISTS ile KullanÄ±m
```sql
-- Ã‡alÄ±ÅŸanÄ± olan departmanlar
SELECT department_name
FROM hr.departments d
WHERE EXISTS (
    SELECT 1
    FROM hr.employees e
    WHERE e.department_id = d.department_id
);
```

### Ã–rnek 3: NOT EXISTS ile KullanÄ±m
```sql
-- Ã‡alÄ±ÅŸanÄ± olmayan departmanlar
SELECT department_name
FROM hr.departments d
WHERE NOT EXISTS (
    SELECT 1
    FROM hr.employees e
    WHERE e.department_id = d.department_id
);
```

---

## 5. SELECT Clause'unda SubQuery

SELECT ifadesinde hesaplama veya ek bilgi iÃ§in kullanÄ±lÄ±r.

```sql
SELECT 
    first_name,
    last_name,
    salary,
    (SELECT AVG(salary) FROM hr.employees) AS avg_salary,
    salary - (SELECT AVG(salary) FROM hr.employees) AS salary_diff
FROM hr.employees;
```

---

## 6. FROM Clause'unda SubQuery (Inline View)

FROM kÄ±smÄ±nda geÃ§ici tablo olarak kullanÄ±lÄ±r.

```sql
-- Departman bazÄ±nda maaÅŸ istatistikleri
SELECT 
    dept_stats.department_id,
    dept_stats.avg_salary,
    dept_stats.max_salary,
    d.department_name
FROM (
    SELECT 
        department_id,
        AVG(salary) AS avg_salary,
        MAX(salary) AS max_salary
    FROM hr.employees
    GROUP BY department_id
) dept_stats
JOIN hr.departments d ON dept_stats.department_id = d.department_id;
```

---

## 7. HAVING Clause'unda SubQuery (Grup Filtreleme Alt Sorgusu)

**Ne Yapar?** GROUP BY sonrasÄ± grup bazÄ±nda filtreleme iÃ§in kullanÄ±lÄ±r.  
**NasÄ±l Ã‡alÄ±ÅŸÄ±r?** Alt sorgu Ã§alÄ±ÅŸÄ±r ve bir deÄŸer dÃ¶ner, HAVING bu deÄŸerle grup sonuÃ§larÄ±nÄ± karÅŸÄ±laÅŸtÄ±rÄ±r.  
**Hangi OperatÃ¶rler?** =, >, <, >=, <=, <> (aggregate fonksiyon sonuÃ§larÄ±yla)  
**Ne Zaman KullanÄ±lÄ±r?** Gruplar arasÄ± karÅŸÄ±laÅŸtÄ±rma yapmak istediÄŸinizde (WHERE grup Ã¶ncesi, HAVING grup sonrasÄ± filtreleme).

```sql
-- Ortalama maaÅŸÄ±, genel ortalamanÄ±n Ã¼stÃ¼nde olan departmanlar
SELECT department_id, AVG(salary) as dept_avg_salary
FROM hr.employees
GROUP BY department_id
HAVING AVG(salary) > (
    SELECT AVG(salary) 
    FROM hr.employees
);
```

---

## SubQuery vs JOIN KarÅŸÄ±laÅŸtÄ±rmasÄ±

### Performans AÃ§Ä±sÄ±ndan

| Durum | SubQuery | JOIN | Tavsiye |
|-------|----------|------|---------|
| **Tek deÄŸer arama** | â­â­â­â­â­ | â­â­â­ | SubQuery kullanÄ±n |
| **Ã‡ok satÄ±r eÅŸleÅŸtirme** | â­â­â­ | â­â­â­â­â­ | JOIN kullanÄ±n |
| **KarmaÅŸÄ±k filtreleme** | â­â­â­â­ | â­â­â­ | SubQuery kullanÄ±n |
| **Ã‡ok tablo birleÅŸtirme** | â­â­ | â­â­â­â­â­ | JOIN kullanÄ±n |

### AynÄ± Sonucu Veren Ã–rnekler

**SubQuery ile:**
```sql
SELECT first_name, last_name
FROM hr.employees
WHERE department_id IN (
    SELECT department_id 
    FROM hr.departments 
    WHERE department_name = 'IT'
);
```

**JOIN ile:**
```sql
SELECT e.first_name, e.last_name
FROM hr.employees e
JOIN hr.departments d ON e.department_id = d.department_id
WHERE d.department_name = 'IT';
```

---

## EXISTS vs IN FarkÄ±

### EXISTS (Ã–nerilen)
```sql
-- Ã‡alÄ±ÅŸanÄ± olan departmanlar
SELECT department_name
FROM hr.departments d
WHERE EXISTS (
    SELECT 1
    FROM hr.employees e
    WHERE e.department_id = d.department_id
);
```

### IN KullanÄ±mÄ±
```sql
-- AynÄ± sonuÃ§ ama potansiyel performans problemi
SELECT department_name
FROM hr.departments
WHERE department_id IN (
    SELECT department_id 
    FROM hr.employees
);
```

**Neden EXISTS daha iyi?**
- NULL deÄŸerlerle sorun yaÅŸamaz
- Ä°lk eÅŸleÅŸmede durur (performans)
- Daha gÃ¼venilir sonuÃ§lar

---

## Performans Ä°puÃ§larÄ±

### 1. SubQuery Optimizasyonu
```sql
-- YAVAÅ: Correlated SubQuery
SELECT first_name, last_name
FROM hr.employees e1
WHERE salary = (
    SELECT MAX(salary)
    FROM hr.employees e2
    WHERE e2.department_id = e1.department_id
);

-- HIZLI: Window Function
SELECT first_name, last_name
FROM (
    SELECT first_name, last_name, salary,
           MAX(salary) OVER(PARTITION BY department_id) as max_dept_salary
    FROM hr.employees
) 
WHERE salary = max_dept_salary;
```

### 2. Ä°ndeks KullanÄ±mÄ±
- SubQuery'de kullanÄ±lan kolonlar **indeksli** olmalÄ±
- EXISTS kullanÄ±rken **SELECT 1** yazÄ±n (SELECT * yerine)
- Correlated SubQuery'lerde **outer table'Ä±n koÅŸullarÄ±** Ã¶nemli

---

## Pratik AlÄ±ÅŸtÄ±rmalar ve Ã‡Ã¶zÃ¼mleri

### ğŸŸ¢ **BAÅLANGIÃ‡ SEVÄ°YESÄ°**

### Soru 1 - Single Row SubQuery
**En az maaÅŸ alan Ã§alÄ±ÅŸanÄ±n(larÄ±n) bilgilerini listeleyin.**

<details>
<summary>ğŸ’¡ Ä°pucu gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

- Hangi SubQuery tÃ¼rÃ¼? **Single Row** (tek deÄŸer dÃ¶ner)
- Hangi operatÃ¶r? **=** (eÅŸitlik)  
- Hangi fonksiyon? **MIN()** (minimum deÄŸer)
- MantÄ±k: "Minimum maaÅŸ nedir?" â†’ "Bu maaÅŸa sahip kimler var?"
</details>

<details>
<summary>âœ… Ã‡Ã¶zÃ¼mÃ¼ gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

```sql
SELECT first_name, last_name, salary
FROM hr.employees
WHERE salary = (SELECT MIN(salary) FROM hr.employees);
```

**Ã‡alÄ±ÅŸma SÄ±rasÄ±:**
1. Alt sorgu Ã§alÄ±ÅŸÄ±r: `SELECT MIN(salary) FROM hr.employees` â†’ SonuÃ§: 2100
2. Ana sorgu ÅŸÃ¶yle olur: `WHERE salary = 2100`
3. 2100 maaÅŸ alan tÃ¼m Ã§alÄ±ÅŸanlar listelenir

**Neden bu kadar kolay?** Minimum maaÅŸ tek bir deÄŸerdir, dolayÄ±sÄ±yla = operatÃ¶rÃ¼ kullanabiliriz.
</details>

---

### Soru 2 - Multiple Row SubQuery
**IT ve Sales departmanlarÄ±nda Ã§alÄ±ÅŸan personeli listeleyin.**

<details>
<summary>ğŸ’¡ Ä°pucu gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

- Hangi SubQuery tÃ¼rÃ¼? **Multiple Row** (birden fazla departman ID'si dÃ¶ner)
- Hangi operatÃ¶r? **IN** (listede var mÄ±?)
- MantÄ±k: "IT ve Sales departmanlarÄ±nÄ±n ID'leri nedir?" â†’ "Bu ID'lerde kimler Ã§alÄ±ÅŸÄ±yor?"
</details>

<details>
<summary>âœ… Ã‡Ã¶zÃ¼mÃ¼ gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

```sql
SELECT first_name, last_name, department_id
FROM hr.employees
WHERE department_id IN (
    SELECT department_id 
    FROM hr.departments 
    WHERE department_name IN ('IT', 'Sales')
);
```

**Ã‡alÄ±ÅŸma SÄ±rasÄ±:**
1. Alt sorgu Ã§alÄ±ÅŸÄ±r: Departman adlarÄ±na gÃ¶re ID'leri bulur â†’ SonuÃ§: [60, 80]
2. Ana sorgu ÅŸÃ¶yle olur: `WHERE department_id IN (60, 80)`
3. Bu departmanlarda Ã§alÄ±ÅŸan tÃ¼m personel listelenir

**Neden IN kullandÄ±k?** Ã‡Ã¼nkÃ¼ birden fazla departman ID'si dÃ¶nÃ¼yor (60, 80)
</details>

---

### ğŸŸ¡ **ORTA SEVÄ°YE**

### Soru 3 - Correlated SubQuery
**Kendi departmanÄ±nÄ±n ortalama maaÅŸÄ±ndan fazla kazanan Ã§alÄ±ÅŸanlarÄ± listeleyin.**

<details>
<summary>ğŸ’¡ Ä°pucu gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

- Hangi SubQuery tÃ¼rÃ¼? **Correlated** (her Ã§alÄ±ÅŸan iÃ§in farklÄ± departman ortalamasÄ±)
- Hangi operatÃ¶r? **>** (bÃ¼yÃ¼ktÃ¼r)
- MantÄ±k: "Bu Ã§alÄ±ÅŸanÄ±n departmanÄ±nÄ±n ortalamasÄ± nedir?" â†’ "Bu Ã§alÄ±ÅŸan ortalamadan fazla mÄ± kazanÄ±yor?"
</details>

<details>
<summary>âœ… Ã‡Ã¶zÃ¼mÃ¼ gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

```sql
SELECT e1.first_name, e1.last_name, e1.salary, e1.department_id
FROM hr.employees e1
WHERE e1.salary > (
    SELECT AVG(e2.salary)
    FROM hr.employees e2
    WHERE e2.department_id = e1.department_id
);
```

**Ã‡alÄ±ÅŸma SÄ±rasÄ± (her satÄ±r iÃ§in):**
1. Ana sorgu bir Ã§alÄ±ÅŸanÄ± okur: Ã–rn. John, Dept_ID=50
2. Alt sorgu o departmanÄ±n ortalamasÄ±nÄ± hesaplar: Dept_50'nin ortalamasÄ± = 3500
3. KarÅŸÄ±laÅŸtÄ±rma: John'un maaÅŸÄ± > 3500 mÄ±?
4. Bu iÅŸlem HER Ã§alÄ±ÅŸan iÃ§in tekrarlanÄ±r

**Neden Correlated?** Ã‡Ã¼nkÃ¼ her Ã§alÄ±ÅŸan iÃ§in farklÄ± departman ortalamasÄ± hesaplanÄ±yor.
</details>

---

### Soru 4 - Multiple Column SubQuery
**Her departmanda en dÃ¼ÅŸÃ¼k maaÅŸlÄ± Ã§alÄ±ÅŸan(larÄ±) bulun.**

<details>
<summary>ğŸ’¡ Ä°pucu gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

- Hangi SubQuery tÃ¼rÃ¼? **Multiple Column** (maaÅŸ + departman Ã§ifti)
- Hangi operatÃ¶r? **IN** (Ã§ift deÄŸer karÅŸÄ±laÅŸtÄ±rmasÄ±)
- MantÄ±k: "Her departmanÄ±n minimum maaÅŸÄ± nedir?" â†’ "Bu (maaÅŸ, departman) Ã§iftlerine sahip kimler var?"
</details>

<details>
<summary>âœ… Ã‡Ã¶zÃ¼mÃ¼ gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

```sql
SELECT first_name, last_name, salary, department_id
FROM hr.employees
WHERE (salary, department_id) IN (
    SELECT MIN(salary), department_id
    FROM hr.employees
    GROUP BY department_id
);
```

**Ã‡alÄ±ÅŸma SÄ±rasÄ±:**
1. Alt sorgu Ã§alÄ±ÅŸÄ±r: Her departmanÄ±n minimum maaÅŸÄ±nÄ± bulur â†’ SonuÃ§: [(2100,10), (3000,20), (2500,30)]
2. Ana sorgu ÅŸÃ¶yle olur: `WHERE (salary, department_id) IN ((2100,10), (3000,20), (2500,30))`
3. Bu Ã§iftlere uyan tÃ¼m Ã§alÄ±ÅŸanlar listelenir

**Neden Ã§ift parantez?** Ã‡Ã¼nkÃ¼ hem maaÅŸ hem departman aynÄ± anda eÅŸleÅŸmeli.
</details>

---

### ğŸ”´ **Ä°LERÄ° SEVÄ°YE**

### Soru 5 - EXISTS KullanÄ±mÄ±
**HiÃ§ Ã§alÄ±ÅŸanÄ± olmayan departmanlarÄ± listeleyin.**

<details>
<summary>ğŸ’¡ Ä°pucu gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

- Hangi SubQuery tÃ¼rÃ¼? **Correlated** (her departman iÃ§in Ã§alÄ±ÅŸan kontrolÃ¼)
- Hangi operatÃ¶r? **NOT EXISTS** (yokluk kontrolÃ¼)
- MantÄ±k: "Bu departmanda Ã§alÄ±ÅŸan var mÄ±?" â†’ "Yoksa departmanÄ± listele"
</details>

<details>
<summary>âœ… Ã‡Ã¶zÃ¼mÃ¼ gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

```sql
SELECT department_name, department_id
FROM hr.departments d
WHERE NOT EXISTS (
    SELECT 1
    FROM hr.employees e
    WHERE e.department_id = d.department_id
);
```

**Ã‡alÄ±ÅŸma SÄ±rasÄ± (her departman iÃ§in):**
1. Ana sorgu bir departmanÄ± okur: Ã–rn. "Marketing", ID=20
2. Alt sorgu bu departmanda Ã§alÄ±ÅŸan var mÄ± kontrol eder
3. EXISTS: Var ise TRUE, yok ise FALSE dÃ¶ner
4. NOT EXISTS: TRUE ise FALSE, FALSE ise TRUE yapar
5. Sadece FALSE (Ã§alÄ±ÅŸanÄ± olmayan) departmanlar listelenir

**Neden EXISTS kullandÄ±k?** IN yerine EXISTS daha performanslÄ± ve NULL gÃ¼venli.
</details>

---

### Soru 6 - FROM Clause SubQuery (Inline View)
**Her departmanÄ±n maaÅŸ istatistiklerini (ortalama, maksimum, minimum) gÃ¶sterin ve departman ismini ekleyin.**

<details>
<summary>ğŸ’¡ Ä°pucu gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

- Hangi SubQuery tÃ¼rÃ¼? **Inline View** (FROM'da geÃ§ici tablo)
- MantÄ±k: "Ã–nce departman istatistiklerini hesapla" â†’ "Sonra bu sonuÃ§larÄ± departman adÄ±yla birleÅŸtir"
</details>

<details>
<summary>âœ… Ã‡Ã¶zÃ¼mÃ¼ gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

```sql
SELECT 
    stats.department_id,
    d.department_name,
    stats.avg_salary,
    stats.max_salary,
    stats.min_salary,
    stats.emp_count
FROM (
    SELECT 
        department_id,
        AVG(salary) AS avg_salary,
        MAX(salary) AS max_salary,
        MIN(salary) AS min_salary,
        COUNT(*) AS emp_count
    FROM hr.employees
    WHERE department_id IS NOT NULL
    GROUP BY department_id
) stats
JOIN hr.departments d ON stats.department_id = d.department_id
ORDER BY stats.avg_salary DESC;
```

**Ã‡alÄ±ÅŸma SÄ±rasÄ±:**
1. Alt sorgu (inline view) Ã§alÄ±ÅŸÄ±r: Her departman iÃ§in istatistikleri hesaplar
2. Bu sonuÃ§ "stats" isimli geÃ§ici tablo gibi davranÄ±r
3. Ana sorgu bu geÃ§ici tabloyu departments ile JOIN eder
4. Son sonuÃ§: Ä°statistikler + departman adlarÄ±

**Neden FROM'da SubQuery?** KarmaÅŸÄ±k hesaplamalarÄ± Ã¶nce yapÄ±p, sonra JOIN iÅŸlemi yapmak daha temiz.
</details>

---

### ğŸŸ£ **UZMAN SEVÄ°YESÄ°**

### Soru 7 - KarmaÅŸÄ±k Karma KullanÄ±m
**Her Ã¼lkede, o Ã¼lkenin ortalama maaÅŸÄ±ndan fazla kazanan Ã§alÄ±ÅŸan sayÄ±sÄ±nÄ± ve bu Ã§alÄ±ÅŸanlarÄ±n toplam maaÅŸÄ±nÄ± gÃ¶sterin.**

<details>
<summary>ğŸ’¡ Ä°pucu gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

- Birden fazla SubQuery tÃ¼rÃ¼ kullanÄ±lacak
- Correlated SubQuery + Inline View
- Multiple JOIN gerekli
- GROUP BY ve aggregate functions
</details>

<details>
<summary>âœ… Ã‡Ã¶zÃ¼mÃ¼ gÃ¶rmek iÃ§in tÄ±klayÄ±n</summary>

```sql
SELECT 
    c.country_name,
    COUNT(*) as high_earner_count,
    SUM(emp_data.salary) as total_salary,
    AVG(emp_data.salary) as avg_salary_of_high_earners
FROM (
    SELECT 
        e.salary,
        l.country_id,
        e.department_id
    FROM hr.employees e
    JOIN hr.departments d ON e.department_id = d.department_id
    JOIN hr.locations l ON d.location_id = l.location_id
    WHERE e.salary > (
        SELECT AVG(e2.salary)
        FROM hr.employees e2
        JOIN hr.departments d2 ON e2.department_id = d2.department_id
        JOIN hr.locations l2 ON d2.location_id = l2.location_id
        WHERE l2.country_id = l.country_id
    )
) emp_data
JOIN hr.countries c ON emp_data.country_id = c.country_id
GROUP BY c.country_name
ORDER BY high_earner_count DESC;
```

**Ã‡alÄ±ÅŸma SÄ±rasÄ±:**
1. **Correlated SubQuery**: Her Ã¼lkenin ortalama maaÅŸÄ±nÄ± hesaplar
2. **Ana WHERE**: Bu ortalamadan fazla kazanan Ã§alÄ±ÅŸanlarÄ± filtreler
3. **Inline View**: Filtrelenen Ã§alÄ±ÅŸanlar geÃ§ici tablo olur
4. **GROUP BY**: Ãœlke bazÄ±nda istatistikleri hesaplar

**Bu soru neden zor?** Ã‡Ã¼nkÃ¼ 3 farklÄ± SubQuery tekniÄŸini bir arada kullanÄ±yor.
</details>

---

### ğŸ¯ **Ã–ÄŸrenme KontrolÃ¼**

Bu sorularÄ± Ã§Ã¶zerken kendinizi test edin:

1. **SubQuery tÃ¼rÃ¼nÃ¼ doÄŸru belirleyebildiniz mi?**
2. **Hangi operatÃ¶rÃ¼ kullanacaÄŸÄ±nÄ±zÄ± bilebildiniz mi?**
3. **Ã‡alÄ±ÅŸma sÄ±rasÄ±nÄ± takip edebildiniz mi?**
4. **Performans aÃ§Ä±sÄ±ndan en iyi Ã§Ã¶zÃ¼mÃ¼ seÃ§ebildiniz mi?**

> **Tavsiye:** Her soruyu Ã¶nce ipucuna bakarak Ã§Ã¶zmeye Ã§alÄ±ÅŸÄ±n, sonra Ã§Ã¶zÃ¼mÃ¼ kontrol edin!

---

## YaygÄ±n Hatalar ve Ã‡Ã¶zÃ¼mleri

### 1. Single Row SubQuery HatasÄ±
```sql
-- HATA: ORA-01427: single-row subquery returns more than one row
SELECT first_name, last_name
FROM hr.employees
WHERE salary = (
    SELECT salary 
    FROM hr.employees 
    WHERE department_id = 50  -- Birden fazla sonuÃ§ dÃ¶ner
);

-- Ã‡Ã–ZÃœM: IN operatÃ¶rÃ¼ kullanÄ±n
SELECT first_name, last_name
FROM hr.employees
WHERE salary IN (
    SELECT salary 
    FROM hr.employees 
    WHERE department_id = 50
);
```

### 2. NULL DeÄŸer Problemi
```sql
-- Problem: NOT IN ile NULL deÄŸerler
SELECT first_name, last_name
FROM hr.employees
WHERE department_id NOT IN (
    SELECT department_id 
    FROM hr.departments 
    WHERE location_id = 1700  -- NULL dÃ¶nen deÄŸer varsa sonuÃ§ boÅŸ gelir
);

-- Ã‡Ã¶zÃ¼m: NULL deÄŸerleri filtreleyin
SELECT first_name, last_name
FROM hr.employees
WHERE department_id NOT IN (
    SELECT department_id 
    FROM hr.departments 
    WHERE location_id = 1700
    AND department_id IS NOT NULL
);
```

### 3. Performans Problemi
```sql
-- YAVAÅ: Her satÄ±r iÃ§in subquery Ã§alÄ±ÅŸÄ±r
SELECT first_name, last_name,
       (SELECT department_name 
        FROM hr.departments d 
        WHERE d.department_id = e.department_id) as dept_name
FROM hr.employees e;

-- HIZLI: JOIN kullanÄ±n
SELECT e.first_name, e.last_name, d.department_name
FROM hr.employees e
LEFT JOIN hr.departments d ON e.department_id = d.department_id;
```

---

## Ã–zet Tablosu

| SubQuery TÃ¼rÃ¼ | KullanÄ±m AlanÄ± | OperatÃ¶rler | Performans |
|----------------|-----------------|-------------|------------|
| **Single Row** | Tek deÄŸer karÅŸÄ±laÅŸtÄ±rma | =, >, <, >=, <=, <> | â­â­â­â­â­ |
| **Multiple Row** | Ã‡ok deÄŸer karÅŸÄ±laÅŸtÄ±rma | IN, ANY, ALL | â­â­â­â­ |
| **Multiple Column** | Ã‡ok kolon karÅŸÄ±laÅŸtÄ±rma | IN, EXISTS | â­â­â­ |
| **Correlated** | Dinamik filtreleme | EXISTS, IN | â­â­ |

---

## Son Tavsiyeler

1. **Basit durumlar iÃ§in** SubQuery, **karmaÅŸÄ±k birleÅŸtirmeler iÃ§in** JOIN tercih edin
2. **EXISTS** operatÃ¶rÃ¼nÃ¼ **IN** yerine kullanmayÄ± tercih edin (NULL gÃ¼venli)
3. **Correlated SubQuery** yerine **Window Functions** kullanmayÄ± dÃ¼ÅŸÃ¼nÃ¼n
4. **SubQuery'lerde** kullanÄ±lan kolonlarÄ±n **indeksli** olduÄŸundan emin olun
5. **EXPLAIN PLAN** ile sorgu performansÄ±nÄ± kontrol edin
6. **KarmaÅŸÄ±k SubQuery'leri** WITH clause (CTE) ile daha okunabilir yapÄ±n

> **HatÄ±rlatma:** Bu Ã¶rneklerde `hr.employees`, `hr.departments` vb. tablolar Oracle HR ÅŸemasÄ± kullanÄ±larak yazÄ±lmÄ±ÅŸtÄ±r. Kendi veritabanÄ±nÄ±zda tablo isimlerini uygun ÅŸekilde deÄŸiÅŸtirin.



### Basit Alt Sorgular

```sql
-- Ortalama maaÅŸtan yÃ¼ksek maaÅŸ alan Ã§alÄ±ÅŸanlar
SELECT FIRST_NAME, LAST_NAME, SALARY
FROM HR.EMPLOYEES
WHERE SALARY > (SELECT AVG(SALARY) FROM HR.EMPLOYEES);

-- En yÃ¼ksek maaÅŸlÄ± Ã§alÄ±ÅŸan
SELECT FIRST_NAME, LAST_NAME, SALARY
FROM HR.EMPLOYEES
WHERE SALARY = (SELECT MAX(SALARY) FROM HR.EMPLOYEES);

-- Belirli bir departmandaki ortalama maaÅŸtan yÃ¼ksek maaÅŸ alanlar
SELECT FIRST_NAME, LAST_NAME, SALARY, DEPARTMENT_ID
FROM HR.EMPLOYEES
WHERE SALARY > (SELECT AVG(SALARY) FROM HR.EMPLOYEES WHERE DEPARTMENT_ID = 90);

-- En Ã§ok Ã§alÄ±ÅŸanÄ± olan departman
SELECT DEPARTMENT_ID, COUNT(*) AS EMP_COUNT
FROM HR.EMPLOYEES
GROUP BY DEPARTMENT_ID
HAVING COUNT(*) = (
    SELECT MAX(EMP_COUNT) FROM (
        SELECT COUNT(*) AS EMP_COUNT 
        FROM HR.EMPLOYEES 
        GROUP BY DEPARTMENT_ID
    )
);
```

### IN ile Alt Sorgular

```sql
-- IT departmanÄ±nda Ã§alÄ±ÅŸanlar
SELECT FIRST_NAME, LAST_NAME
FROM HR.EMPLOYEES
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID 
                       FROM HR.DEPARTMENTS 
                       WHERE DEPARTMENT_NAME LIKE '%IT%');

-- Komisyon alan Ã§alÄ±ÅŸanlarla aynÄ± departmanda Ã§alÄ±ÅŸanlar
SELECT FIRST_NAME, LAST_NAME, DEPARTMENT_ID
FROM HR.EMPLOYEES
WHERE DEPARTMENT_ID IN (SELECT DISTINCT DEPARTMENT_ID 
                       FROM HR.EMPLOYEES 
                       WHERE COMMISSION_PCT IS NOT NULL);

-- Amerika'da bulunan departmanlardaki Ã§alÄ±ÅŸanlar
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME
FROM HR.EMPLOYEES E
JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE D.LOCATION_ID IN (
    SELECT L.LOCATION_ID 
    FROM HR.LOCATIONS L
    JOIN HR.COUNTRIES C ON L.COUNTRY_ID = C.COUNTRY_ID
    WHERE C.COUNTRY_NAME = 'United States of America'
);

-- Ä°ÅŸ geÃ§miÅŸi olan Ã§alÄ±ÅŸanlar
SELECT FIRST_NAME, LAST_NAME
FROM HR.EMPLOYEES
WHERE EMPLOYEE_ID IN (SELECT DISTINCT EMPLOYEE_ID FROM HR.JOB_HISTORY);
```

### EXISTS ile Alt Sorgular

```sql
-- Ã‡alÄ±ÅŸanÄ± olan departmanlar
SELECT DEPARTMENT_NAME
FROM HR.DEPARTMENTS D
WHERE EXISTS (SELECT 1 FROM HR.EMPLOYEES E WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID);

-- Ã‡alÄ±ÅŸanÄ± olmayan departmanlar
SELECT DEPARTMENT_NAME
FROM HR.DEPARTMENTS D
WHERE NOT EXISTS (SELECT 1 FROM HR.EMPLOYEES E WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID);

-- Ä°ÅŸ geÃ§miÅŸi olan Ã§alÄ±ÅŸanlar (EXISTS ile)
SELECT FIRST_NAME, LAST_NAME
FROM HR.EMPLOYEES E
WHERE EXISTS (SELECT 1 FROM HR.JOB_HISTORY JH WHERE JH.EMPLOYEE_ID = E.EMPLOYEE_ID);

-- Lokasyonu olan Ã¼lkeler
SELECT COUNTRY_NAME
FROM HR.COUNTRIES C
WHERE EXISTS (SELECT 1 FROM HR.LOCATIONS L WHERE L.COUNTRY_ID = C.COUNTRY_ID);
```

### Correlated Subqueries

```sql
-- Her departmandaki en yÃ¼ksek maaÅŸlÄ± Ã§alÄ±ÅŸanlar
SELECT FIRST_NAME, LAST_NAME, SALARY, DEPARTMENT_ID
FROM HR.EMPLOYEES E1
WHERE SALARY = (SELECT MAX(SALARY) 
               FROM HR.EMPLOYEES E2 
               WHERE E2.DEPARTMENT_ID = E1.DEPARTMENT_ID);

-- Her Ã§alÄ±ÅŸanÄ±n departmanÄ±ndaki ortalama maaÅŸla karÅŸÄ±laÅŸtÄ±rmasÄ±
SELECT FIRST_NAME, LAST_NAME, SALARY, DEPARTMENT_ID,
       (SELECT AVG(SALARY) FROM HR.EMPLOYEES E2 WHERE E2.DEPARTMENT_ID = E1.DEPARTMENT_ID) AS DEPT_AVG
FROM HR.EMPLOYEES E1;

-- DepartmanÄ±nda en son iÅŸe alÄ±nan Ã§alÄ±ÅŸanlar
SELECT FIRST_NAME, LAST_NAME, HIRE_DATE, DEPARTMENT_ID
FROM HR.EMPLOYEES E1
WHERE HIRE_DATE = (SELECT MAX(HIRE_DATE) 
                  FROM HR.EMPLOYEES E2 
                  WHERE E2.DEPARTMENT_ID = E1.DEPARTMENT_ID);

-- Her iÅŸ pozisyonundaki en dÃ¼ÅŸÃ¼k maaÅŸlÄ± Ã§alÄ±ÅŸanlar
SELECT FIRST_NAME, LAST_NAME, JOB_ID, SALARY
FROM HR.EMPLOYEES E1
WHERE SALARY = (SELECT MIN(SALARY)
               FROM HR.EMPLOYEES E2
               WHERE E2.JOB_ID = E1.JOB_ID);
```

### Ã‡oklu SÃ¼tun Alt SorgularÄ±

```sql
-- Departman ve iÅŸ pozisyonundaki maksimum maaÅŸÄ± alan Ã§alÄ±ÅŸanlar
SELECT FIRST_NAME, LAST_NAME, SALARY, DEPARTMENT_ID, JOB_ID
FROM HR.EMPLOYEES
WHERE (DEPARTMENT_ID, JOB_ID, SALARY) IN 
      (SELECT DEPARTMENT_ID, JOB_ID, MAX(SALARY)
       FROM HR.EMPLOYEES
       WHERE DEPARTMENT_ID IS NOT NULL
       GROUP BY DEPARTMENT_ID, JOB_ID);

-- Her departman ve lokasyon kombinasyonundaki ilk Ã§alÄ±ÅŸan
SELECT E.FIRST_NAME, E.LAST_NAME, E.DEPARTMENT_ID, D.LOCATION_ID, E.HIRE_DATE
FROM HR.EMPLOYEES E
JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE (E.DEPARTMENT_ID, D.LOCATION_ID, E.HIRE_DATE) IN (
    SELECT E2.DEPARTMENT_ID, D2.LOCATION_ID, MIN(E2.HIRE_DATE)
    FROM HR.EMPLOYEES E2
    JOIN HR.DEPARTMENTS D2 ON E2.DEPARTMENT_ID = D2.DEPARTMENT_ID
    GROUP BY E2.DEPARTMENT_ID, D2.LOCATION_ID
);
```

### Pratik AlÄ±ÅŸtÄ±rma 6
```sql
-- 1. Åirket ortalamasÄ±ndan yÃ¼ksek maaÅŸ alan Ã§alÄ±ÅŸanlarÄ±n departman daÄŸÄ±lÄ±mÄ±
SELECT D.DEPARTMENT_NAME, COUNT(*) AS HIGH_EARNERS
FROM HR.EMPLOYEES E
JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.SALARY > (SELECT AVG(SALARY) FROM HR.EMPLOYEES)
GROUP BY D.DEPARTMENT_NAME
ORDER BY HIGH_EARNERS DESC;

-- 2. Her departmandaki en dÃ¼ÅŸÃ¼k maaÅŸlÄ± Ã§alÄ±ÅŸanlarÄ± bulun
SELECT FIRST_NAME, LAST_NAME, SALARY, DEPARTMENT_ID
FROM HR.EMPLOYEES E1
WHERE SALARY = (SELECT MIN(SALARY) 
               FROM HR.EMPLOYEES E2 
               WHERE E2.DEPARTMENT_ID = E1.DEPARTMENT_ID)
ORDER BY DEPARTMENT_ID;

-- 3. HiÃ§ Ã§alÄ±ÅŸanÄ± olmayan departmanlarÄ± listeleyin
SELECT DEPARTMENT_NAME, DEPARTMENT_ID
FROM HR.DEPARTMENTS
WHERE DEPARTMENT_ID NOT IN (SELECT DISTINCT DEPARTMENT_ID 
                           FROM HR.EMPLOYEES 
                           WHERE DEPARTMENT_ID IS NOT NULL);

-- 4. Ä°ÅŸ geÃ§miÅŸi olmayan Ã§alÄ±ÅŸanlarÄ± bulun
SELECT FIRST_NAME, LAST_NAME, HIRE_DATE
FROM HR.EMPLOYEES E
WHERE NOT EXISTS (SELECT 1 FROM HR.JOB_HISTORY JH WHERE JH.EMPLOYEE_ID = E.EMPLOYEE_ID);

-- 5. En fazla Ã§alÄ±ÅŸanÄ± olan ÅŸehirdeki departmanlarÄ± listeleyin
SELECT D.DEPARTMENT_NAME, L.CITY, COUNT(E.EMPLOYEE_ID) AS EMP_COUNT
FROM HR.DEPARTMENTS D
JOIN HR.LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
JOIN HR.EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
WHERE L.CITY = (
    SELECT CITY FROM (
        SELECT L2.CITY, COUNT(E2.EMPLOYEE_ID) AS EMP_COUNT
        FROM HR.LOCATIONS L2
        JOIN HR.DEPARTMENTS D2 ON L2.LOCATION_ID = D2.LOCATION_ID
        JOIN HR.EMPLOYEES E2 ON D2.DEPARTMENT_ID = E2.DEPARTMENT_ID
        GROUP BY L2.CITY
        ORDER BY EMP_COUNT DESC
    ) WHERE ROWNUM = 1
)
GROUP BY D.DEPARTMENT_NAME, L.CITY;
```

## ğŸ‹ï¸ **OTURUM 6 - ALIÅTIRMALAR**

### **KOLAY SEVÄ°YE (3 Soru)**

**1. En yÃ¼ksek maaÅŸlÄ± Ã§alÄ±ÅŸanla aynÄ± departmanda Ã§alÄ±ÅŸanlarÄ± bulun.**
```sql
-- SORU 1 CEVABI:
SELECT FIRST_NAME, LAST_NAME, SALARY, DEPARTMENT_ID
FROM HR.EMPLOYEES
WHERE DEPARTMENT_ID = (
    SELECT DEPARTMENT_ID 
    FROM HR.EMPLOYEES 
    WHERE SALARY = (SELECT MAX(SALARY) FROM HR.EMPLOYEES)
)
ORDER BY SALARY DESC;
```

**2. Ortalama maaÅŸtan dÃ¼ÅŸÃ¼k maaÅŸ alan Ã§alÄ±ÅŸan sayÄ±sÄ±nÄ± bulun.**
```sql
-- SORU 2 CEVABI:
SELECT COUNT(*) AS BELOW_AVERAGE_COUNT,
       (SELECT COUNT(*) FROM HR.EMPLOYEES) AS TOTAL_EMPLOYEES,
       ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM HR.EMPLOYEES), 2) AS PERCENTAGE
FROM HR.EMPLOYEES
WHERE SALARY < (SELECT AVG(SALARY) FROM HR.EMPLOYEES);
```

**3. 'Sales' bÃ¶lÃ¼mÃ¼nde Ã§alÄ±ÅŸan personelleri listeleyin.**
```sql
-- SORU 3 CEVABI:
SELECT E.FIRST_NAME, E.LAST_NAME, E.SALARY
FROM HR.EMPLOYEES E
WHERE E.DEPARTMENT_ID IN (
    SELECT DEPARTMENT_ID 
    FROM HR.DEPARTMENTS 
    WHERE DEPARTMENT_NAME LIKE '%Sales%'
)
ORDER BY E.SALARY DESC;
```

### **ORTA SEVÄ°YE (3 Soru)**

**4. Her departmandaki en yÃ¼ksek maaÅŸlÄ± ikinci kiÅŸiyi bulun.**
```sql
-- SORU 4 CEVABI:
SELECT E1.FIRST_NAME, E1.LAST_NAME, E1.SALARY, E1.DEPARTMENT_ID
FROM HR.EMPLOYEES E1
WHERE 2 = (
    SELECT COUNT(DISTINCT E2.SALARY)
    FROM HR.EMPLOYEES E2
    WHERE E2.DEPARTMENT_ID = E1.DEPARTMENT_ID 
    AND E2.SALARY >= E1.SALARY
)
ORDER BY E1.DEPARTMENT_ID;
```

**5. Kendi departmanÄ±nÄ±n ortalama maaÅŸÄ±ndan %20 fazla kazanan Ã§alÄ±ÅŸanlarÄ± bulun.**
```sql
-- SORU 5 CEVABI:
SELECT E1.FIRST_NAME, E1.LAST_NAME, E1.SALARY, E1.DEPARTMENT_ID,
       (SELECT ROUND(AVG(SALARY), 2) FROM HR.EMPLOYEES E2 WHERE E2.DEPARTMENT_ID = E1.DEPARTMENT_ID) AS DEPT_AVG
FROM HR.EMPLOYEES E1
WHERE E1.SALARY > (
    SELECT AVG(SALARY) * 1.2 
    FROM HR.EMPLOYEES E2 
    WHERE E2.DEPARTMENT_ID = E1.DEPARTMENT_ID
)
ORDER BY E1.DEPARTMENT_ID, E1.SALARY DESC;
```

**6. HiÃ§ yÃ¶neticilik yapmamÄ±ÅŸ Ã§alÄ±ÅŸanlarÄ± bulun.**
```sql
-- SORU 6 CEVABI:
SELECT FIRST_NAME, LAST_NAME, JOB_ID
FROM HR.EMPLOYEES E
WHERE NOT EXISTS (
    SELECT 1 FROM HR.EMPLOYEES E2 WHERE E2.MANAGER_ID = E.EMPLOYEE_ID
)
AND NOT EXISTS (
    SELECT 1 FROM HR.DEPARTMENTS D WHERE D.MANAGER_ID = E.EMPLOYEE_ID
)
ORDER BY LAST_NAME;
```

### **ZOR SEVÄ°YE (2 Soru)**

**7. En az 3 farklÄ± iÅŸ pozisyonunun bulunduÄŸu departmanlarÄ± ve bu pozisyonlarÄ± listeleyin.**
```sql
-- SORU 7 CEVABI:
SELECT D.DEPARTMENT_NAME,
       (SELECT COUNT(DISTINCT JOB_ID) FROM HR.EMPLOYEES E WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID) AS JOB_COUNT,
       (SELECT LISTAGG(DISTINCT J.JOB_TITLE, ', ') WITHIN GROUP (ORDER BY J.JOB_TITLE)
        FROM HR.EMPLOYEES E2 
        JOIN HR.JOBS J ON E2.JOB_ID = J.JOB_ID
        WHERE E2.DEPARTMENT_ID = D.DEPARTMENT_ID) AS JOB_TITLES
FROM HR.DEPARTMENTS D
WHERE (SELECT COUNT(DISTINCT JOB_ID) FROM HR.EMPLOYEES E WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID) >= 3
ORDER BY JOB_COUNT DESC;
```

**8. MaaÅŸ daÄŸÄ±lÄ±mÄ±nda Ã¼st %10'da olan Ã§alÄ±ÅŸanlarÄ± ve bunlarÄ±n Ã¶zelliklerini analiz edin.**
```sql
-- SORU 8 CEVABI:
WITH SALARY_PERCENTILES AS (
    SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, SALARY,
           PERCENT_RANK() OVER (ORDER BY SALARY DESC) AS SALARY_PERCENTILE
    FROM HR.EMPLOYEES
),
TOP_10_PERCENT AS (
    SELECT * FROM SALARY_PERCENTILES WHERE SALARY_PERCENTILE <= 0.1
)
SELECT T.FIRST_NAME, T.LAST_NAME, T.SALARY, D.DEPARTMENT_NAME, J.JOB_TITLE,
       L.CITY, C.COUNTRY_NAME,
       ROUND(MONTHS_BETWEEN(SYSDATE, E.HIRE_DATE)/12, 1) AS YEARS_EXPERIENCE,
       CASE WHEN E.COMMISSION_PCT IS NOT NULL THEN 'Has Commission' ELSE 'No Commission' END AS COMMISSION_STATUS,
       (SELECT COUNT(*) FROM HR.EMPLOYEES E2 WHERE E2.MANAGER_ID = E.EMPLOYEE_ID) AS DIRECT_REPORTS
FROM TOP_10_PERCENT T
JOIN HR.EMPLOYEES E ON T.EMPLOYEE_ID = E.EMPLOYEE_ID
JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN HR.JOBS J ON E.JOB_ID = J.JOB_ID
JOIN HR.LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
JOIN HR.COUNTRIES C ON L.COUNTRY_ID = C.COUNTRY_ID
ORDER BY T.SALARY DESC;
```

---

## **7. OTURUM: GELÄ°ÅMÄ°Å SQL KONULARI**

### UNION ve UNION ALL

```sql
-- YÃ¼ksek maaÅŸlÄ± Ã§alÄ±ÅŸanlar ve yÃ¶neticileri birleÅŸtir
SELECT FIRST_NAME, LAST_NAME, 'High Salary' AS CATEGORY, SALARY
FROM HR.EMPLOYEES
WHERE SALARY > 10000
UNION
SELECT FIRST_NAME, LAST_NAME, 'Manager' AS CATEGORY, SALARY
FROM HR.EMPLOYEES
WHERE EMPLOYEE_ID IN (SELECT DISTINCT MANAGER_ID FROM HR.EMPLOYEES WHERE MANAGER_ID IS NOT NULL);

-- UNION ALL (duplikatlarÄ± korur)
SELECT FIRST_NAME, LAST_NAME, DEPARTMENT_ID
FROM HR.EMPLOYEES
WHERE DEPARTMENT_ID = 10
UNION ALL
SELECT FIRST_NAME, LAST_NAME, DEPARTMENT_ID
FROM HR.EMPLOYEES
WHERE SALARY > 5000;

-- FarklÄ± tablolardan veri birleÅŸtirme
SELECT 'Employee' AS TYPE, FIRST_NAME || ' ' || LAST_NAME AS NAME, TO_CHAR(EMPLOYEE_ID) AS ID
FROM HR.EMPLOYEES
UNION
SELECT 'Department' AS TYPE, DEPARTMENT_NAME AS NAME, TO_CHAR(DEPARTMENT_ID) AS ID
FROM HR.DEPARTMENTS
UNION
SELECT 'Location' AS TYPE, CITY AS NAME, TO_CHAR(LOCATION_ID) AS ID
FROM HR.LOCATIONS
ORDER BY TYPE, NAME;
```

### Analytic Functions - SÄ±ralama FonksiyonlarÄ±

```sql
-- ROW_NUMBER: Benzersiz sÄ±ra numarasÄ±
SELECT FIRST_NAME, LAST_NAME, SALARY,
       ROW_NUMBER() OVER (ORDER BY SALARY DESC) AS ROW_NUM
FROM HR.EMPLOYEES;

-- RANK: AynÄ± deÄŸerler iÃ§in aynÄ± sÄ±ra
SELECT FIRST_NAME, LAST_NAME, SALARY,
       RANK() OVER (ORDER BY SALARY DESC) AS RANK_NUM
FROM HR.EMPLOYEES;

-- DENSE_RANK: BoÅŸluk bÄ±rakmadan sÄ±ralama
SELECT FIRST_NAME, LAST_NAME, SALARY,
       DENSE_RANK() OVER (ORDER BY SALARY DESC) AS DENSE_RANK_NUM
FROM HR.EMPLOYEES;

-- Departman iÃ§inde sÄ±ralama
SELECT FIRST_NAME, LAST_NAME, DEPARTMENT_ID, SALARY,
       ROW_NUMBER() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) AS DEPT_RANK,
       RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) AS DEPT_RANK_WITH_TIES
FROM HR.EMPLOYEES
ORDER BY DEPARTMENT_ID, DEPT_RANK;

-- NTILE: Veriyi eÅŸit gruplara bÃ¶l
SELECT FIRST_NAME, LAST_NAME, SALARY,
       NTILE(4) OVER (ORDER BY SALARY) AS SALARY_QUARTILE
FROM HR.EMPLOYEES;
```

### Window Functions

```sql
-- Her departmandaki en yÃ¼ksek, en dÃ¼ÅŸÃ¼k maaÅŸ ve Ã§alÄ±ÅŸan sayÄ±sÄ±
SELECT FIRST_NAME, LAST_NAME, DEPARTMENT_ID, SALARY,
       MAX(SALARY) OVER (PARTITION BY DEPARTMENT_ID) AS MAX_DEPT_SALARY,
       MIN(SALARY) OVER (PARTITION BY DEPARTMENT_ID) AS MIN_DEPT_SALARY,
       COUNT(*) OVER (PARTITION BY DEPARTMENT_ID) AS DEPT_EMP_COUNT,
       AVG(SALARY) OVER (PARTITION BY DEPARTMENT_ID) AS AVG_DEPT_SALARY
FROM HR.EMPLOYEES
ORDER BY DEPARTMENT_ID, SALARY DESC;

-- KÃ¼mÃ¼latif toplam
SELECT FIRST_NAME, LAST_NAME, HIRE_DATE, SALARY,
       SUM(SALARY) OVER (ORDER BY HIRE_DATE ROWS UNBOUNDED PRECEDING) AS CUMULATIVE_SALARY
FROM HR.EMPLOYEES
ORDER BY HIRE_DATE;

-- Ã–nceki ve sonraki deÄŸerler
SELECT FIRST_NAME, LAST_NAME, SALARY,
       LAG(SALARY, 1) OVER (ORDER BY SALARY) AS PREV_SALARY,
       LEAD(SALARY, 1) OVER (ORDER BY SALARY) AS NEXT_SALARY,
       SALARY - LAG(SALARY, 1) OVER (ORDER BY SALARY) AS SALARY_DIFF
FROM HR.EMPLOYEES
ORDER BY SALARY;

-- Ä°lk ve son deÄŸerler
SELECT FIRST_NAME, LAST_NAME, DEPARTMENT_ID, SALARY,
       FIRST_VALUE(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) AS HIGHEST_IN_DEPT,
       LAST_VALUE(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC 
                               ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS LOWEST_IN_DEPT
FROM HR.EMPLOYEES
ORDER BY DEPARTMENT_ID, SALARY DESC;

-- YÃ¼zdelik dilim
SELECT FIRST_NAME, LAST_NAME, SALARY,
       PERCENT_RANK() OVER (ORDER BY SALARY) * 100 AS SALARY_PERCENTILE,
       CUME_DIST() OVER (ORDER BY SALARY) * 100 AS CUMULATIVE_DISTRIBUTION
FROM HR.EMPLOYEES
ORDER BY SALARY DESC;
```

### WITH (Common Table Expressions - CTE)

```sql
-- Basit CTE
WITH HIGH_EARNERS AS (
    SELECT FIRST_NAME, LAST_NAME, SALARY, DEPARTMENT_ID
    FROM HR.EMPLOYEES
    WHERE SALARY > (SELECT AVG(SALARY) FROM HR.EMPLOYEES)
)
SELECT D.DEPARTMENT_NAME, COUNT(*) AS HIGH_EARNER_COUNT
FROM HIGH_EARNERS H
JOIN HR.DEPARTMENTS D ON H.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME
ORDER BY HIGH_EARNER_COUNT DESC;

-- Ã‡oklu CTE
WITH 
DEPT_STATS AS (
    SELECT DEPARTMENT_ID, AVG(SALARY) AS AVG_SALARY, COUNT(*) AS EMP_COUNT
    FROM HR.EMPLOYEES
    GROUP BY DEPARTMENT_ID
),
HIGH_SALARY_DEPTS AS (
    SELECT DEPARTMENT_ID
    FROM DEPT_STATS
    WHERE AVG_SALARY > 8000
),
LOCATION_INFO AS (
    SELECT D.DEPARTMENT_ID, D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME
    FROM HR.DEPARTMENTS D
    JOIN HR.LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
    JOIN HR.COUNTRIES C ON L.COUNTRY_ID = C.COUNTRY_ID
)
SELECT E.FIRST_NAME, E.LAST_NAME, E.SALARY, LI.DEPARTMENT_NAME, LI.CITY, LI.COUNTRY_NAME
FROM HR.EMPLOYEES E
JOIN HIGH_SALARY_DEPTS HSD ON E.DEPARTMENT_ID = HSD.DEPARTMENT_ID
JOIN LOCATION_INFO LI ON E.DEPARTMENT_ID = LI.DEPARTMENT_ID
ORDER BY E.SALARY DESC;

-- Recursive CTE (Organizasyon hiyerarÅŸisi)
WITH ORG_HIERARCHY AS (
    -- Base case: Top level managers
    SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, MANAGER_ID, 1 AS LEVEL,
           FIRST_NAME || ' ' || LAST_NAME AS PATH
    FROM HR.EMPLOYEES
    WHERE MANAGER_ID IS NULL
    
    UNION ALL
    
    -- Recursive case
    SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.MANAGER_ID, OH.LEVEL + 1,
           OH.PATH || ' -> ' || E.FIRST_NAME || ' ' || E.LAST_NAME
    FROM HR.EMPLOYEES E
    JOIN ORG_HIERARCHY OH ON E.MANAGER_ID = OH.EMPLOYEE_ID
    WHERE OH.LEVEL < 10  -- Sonsuz dÃ¶ngÃ¼yÃ¼ Ã¶nlemek iÃ§in
)
SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, LEVEL, PATH
FROM ORG_HIERARCHY
ORDER BY LEVEL, LAST_NAME;
```

### PIVOT ve UNPIVOT Ä°ÅŸlemleri

```sql
-- Departman bazÄ±nda iÅŸ pozisyonlarÄ± daÄŸÄ±lÄ±mÄ± (PIVOT)
SELECT * FROM (
    SELECT D.DEPARTMENT_NAME, E.JOB_ID
    FROM HR.EMPLOYEES E
    JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
)
PIVOT (
    COUNT(*) 
    FOR JOB_ID IN ('IT_PROG' AS "IT Programmer", 
                   'SA_REP' AS "Sales Rep", 
                   'ST_CLERK' AS "Stock Clerk",
                   'FI_ACCOUNT' AS "Finance Accountant")
);

-- YÄ±llÄ±k iÅŸe alÄ±m trendleri (PIVOT)
SELECT * FROM (
    SELECT DEPARTMENT_ID, EXTRACT(YEAR FROM HIRE_DATE) AS HIRE_YEAR
    FROM HR.EMPLOYEES
    WHERE EXTRACT(YEAR FROM HIRE_DATE) BETWEEN 2005 AND 2008
)
PIVOT (
    COUNT(*)
    FOR HIRE_YEAR IN (2005, 2006, 2007, 2008)
)
ORDER BY DEPARTMENT_ID;
```

### GeliÅŸmiÅŸ Analytic Functions

```sql
-- Moving Average (Hareketli Ortalama)
SELECT FIRST_NAME, LAST_NAME, HIRE_DATE, SALARY,
       AVG(SALARY) OVER (ORDER BY HIRE_DATE ROWS BETWEEN 2 PRECEDING AND CURRENT ROW) AS MOVING_AVG_3
FROM HR.EMPLOYEES
ORDER BY HIRE_DATE;

-- Departman iÃ§inde kÃ¼mÃ¼latif yÃ¼zde
SELECT FIRST_NAME, LAST_NAME, DEPARTMENT_ID, SALARY,
       SALARY / SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID) * 100 AS DEPT_SALARY_PERCENTAGE,
       SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC 
                        ROWS UNBOUNDED PRECEDING) / 
       SUM(SALARY) OVER (PARTITION BY DEPARTMENT_ID) * 100 AS CUMULATIVE_PERCENTAGE
FROM HR.EMPLOYEES
ORDER BY DEPARTMENT_ID, SALARY DESC;
```

### Pratik AlÄ±ÅŸtÄ±rma 7
```sql
-- 1. Her departmandaki en yÃ¼ksek 3 maaÅŸlÄ± Ã§alÄ±ÅŸanÄ± bulun
WITH RANKED_EMPLOYEES AS (
    SELECT FIRST_NAME, LAST_NAME, SALARY, DEPARTMENT_ID,
           ROW_NUMBER() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) AS RN
    FROM HR.EMPLOYEES
    WHERE DEPARTMENT_ID IS NOT NULL
)
SELECT E.FIRST_NAME, E.LAST_NAME, E.SALARY, D.DEPARTMENT_NAME
FROM RANKED_EMPLOYEES E
JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE E.RN <= 3
ORDER BY E.DEPARTMENT_ID, E.RN;

-- 2. Departman bazÄ±nda maaÅŸ yÃ¼zdeliklerini hesaplayÄ±n
SELECT FIRST_NAME, LAST_NAME, DEPARTMENT_ID, SALARY,
       ROUND(PERCENT_RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY) * 100, 2) AS SALARY_PERCENTILE_IN_DEPT,
       ROUND(PERCENT_RANK() OVER (ORDER BY SALARY) * 100, 2) AS SALARY_PERCENTILE_COMPANY
FROM HR.EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
ORDER BY DEPARTMENT_ID, SALARY DESC;

-- 3. Her Ã§alÄ±ÅŸanÄ±n maaÅŸÄ±nÄ±n departman ortalamasÄ±na oranÄ±nÄ± bulun
WITH DEPT_AVG AS (
    SELECT DEPARTMENT_ID, AVG(SALARY) AS AVG_SALARY
    FROM HR.EMPLOYEES
    GROUP BY DEPARTMENT_ID
)
SELECT E.FIRST_NAME, E.LAST_NAME, E.SALARY, 
       DA.AVG_SALARY,
       ROUND((E.SALARY / DA.AVG_SALARY) * 100, 2) AS SALARY_RATIO_PCT,
       CASE 
           WHEN E.SALARY > DA.AVG_SALARY * 1.2 THEN 'Above Average'
           WHEN E.SALARY < DA.AVG_SALARY * 0.8 THEN 'Below Average'
           ELSE 'Average'
       END AS PERFORMANCE_CATEGORY
FROM HR.EMPLOYEES E
JOIN DEPT_AVG DA ON E.DEPARTMENT_ID = DA.DEPARTMENT_ID
ORDER BY SALARY_RATIO_PCT DESC;

-- 4. Ã‡alÄ±ÅŸanlarÄ±n maaÅŸ artÄ±ÅŸ trendini analiz edin (iÅŸ geÃ§miÅŸi tablosunu kullanarak)
WITH SALARY_HISTORY AS (
    SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.SALARY AS CURRENT_SALARY,
           JH.START_DATE, JH.END_DATE, J.JOB_TITLE,
           LAG(JH.END_DATE) OVER (PARTITION BY E.EMPLOYEE_ID ORDER BY JH.START_DATE) AS PREV_END_DATE
    FROM HR.EMPLOYEES E
    JOIN HR.JOB_HISTORY JH ON E.EMPLOYEE_ID = JH.EMPLOYEE_ID
    JOIN HR.JOBS J ON JH.JOB_ID = J.JOB_ID
)
SELECT FIRST_NAME, LAST_NAME, CURRENT_SALARY, JOB_TITLE,
       MONTHS_BETWEEN(END_DATE, START_DATE) AS MONTHS_IN_POSITION,
       COUNT(*) OVER (PARTITION BY EMPLOYEE_ID) AS TOTAL_JOB_CHANGES
FROM SALARY_HISTORY
ORDER BY EMPLOYEE_ID, START_DATE;
```

## ğŸ‹ï¸ **OTURUM 7 - ALIÅTIRMALAR**

### **KOLAY SEVÄ°YE (3 Soru)**

**1. Ã‡alÄ±ÅŸanlarÄ± maaÅŸ sÄ±rasÄ±na gÃ¶re numaralandÄ±rÄ±n (ROW_NUMBER kullanÄ±n).**
```sql
-- SORU 1 CEVABI:
SELECT FIRST_NAME, LAST_NAME, SALARY,
       ROW_NUMBER() OVER (ORDER BY SALARY DESC) AS SALARY_RANK
FROM HR.EMPLOYEES
ORDER BY SALARY_RANK;
```

**2. Her departmandaki Ã§alÄ±ÅŸanlarÄ± departman iÃ§inde maaÅŸ sÄ±rasÄ±na gÃ¶re sÄ±ralayÄ±n.**
```sql
-- SORU 2 CEVABI:
SELECT FIRST_NAME, LAST_NAME, DEPARTMENT_ID, SALARY,
       RANK() OVER (PARTITION BY DEPARTMENT_ID ORDER BY SALARY DESC) AS DEPT_RANK
FROM HR.EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
ORDER BY DEPARTMENT_ID, DEPT_RANK;
```

**3. YÃ¼ksek ve dÃ¼ÅŸÃ¼k maaÅŸlÄ± Ã§alÄ±ÅŸanlarÄ± UNION ile birleÅŸtirin.**
```sql
-- SORU 3 CEVABI:
SELECT FIRST_NAME, LAST_NAME, SALARY, 'HIGH EARNER' AS CATEGORY
FROM HR.EMPLOYEES
WHERE SALARY > 15000
UNION
SELECT FIRST_NAME, LAST_NAME, SALARY, 'LOW EARNER' AS CATEGORY
FROM HR.EMPLOYEES
WHERE SALARY < 3000
ORDER BY SALARY DESC;
```

### **ORTA SEVÄ°YE (3 Soru)**

**4. Ã‡alÄ±ÅŸanlarÄ± maaÅŸ bazÄ±nda 4 eÅŸit gruba bÃ¶len sorgu yazÄ±n (NTILE kullanÄ±n).**
```sql
-- SORU 4 CEVABI:
SELECT FIRST_NAME, LAST_NAME, SALARY,
       NTILE(4) OVER (ORDER BY SALARY) AS SALARY_QUARTILE,
       CASE NTILE(4) OVER (ORDER BY SALARY)
           WHEN 1 THEN 'Q1 - Lowest 25%'
           WHEN 2 THEN 'Q2 - Lower Middle 25%'
           WHEN 3 THEN 'Q3 - Upper Middle 25%'
           WHEN 4 THEN 'Q4 - Highest 25%'
       END AS QUARTILE_DESCRIPTION
FROM HR.EMPLOYEES
ORDER BY SALARY_QUARTILE, SALARY;
```

**5. Her Ã§alÄ±ÅŸan iÃ§in departmanÄ±ndaki maksimum, minimum ve ortalama maaÅŸÄ± gÃ¶sterin.**
```sql
-- SORU 5 CEVABI:
SELECT FIRST_NAME, LAST_NAME, SALARY, DEPARTMENT_ID,
       MAX(SALARY) OVER (PARTITION BY DEPARTMENT_ID) AS MAX_DEPT_SALARY,
       MIN(SALARY) OVER (PARTITION BY DEPARTMENT_ID) AS MIN_DEPT_SALARY,
       ROUND(AVG(SALARY) OVER (PARTITION BY DEPARTMENT_ID), 2) AS AVG_DEPT_SALARY,
       SALARY - AVG(SALARY) OVER (PARTITION BY DEPARTMENT_ID) AS DIFF_FROM_AVG
FROM HR.EMPLOYEES
WHERE DEPARTMENT_ID IS NOT NULL
ORDER BY DEPARTMENT_ID, SALARY DESC;
```

**6. LAG ve LEAD fonksiyonlarÄ±nÄ± kullanarak her Ã§alÄ±ÅŸanÄ±n Ã¶nceki ve sonraki maaÅŸÄ±nÄ± gÃ¶sterin.**
```sql
-- SORU 6 CEVABI:
SELECT FIRST_NAME, LAST_NAME, SALARY,
       LAG(SALARY, 1) OVER (ORDER BY SALARY) AS PREVIOUS_SALARY,
       LEAD(SALARY, 1) OVER (ORDER BY SALARY) AS NEXT_SALARY,
       SALARY - LAG(SALARY, 1) OVER (ORDER BY SALARY) AS DIFF_FROM_PREVIOUS
FROM HR.EMPLOYEES
ORDER BY SALARY;
```

### **ZOR SEVÄ°YE (2 Soru)**

**7. Running total (kÃ¼mÃ¼latif toplam) hesaplayÄ±n ve maaÅŸ daÄŸÄ±lÄ±mÄ±nÄ± analiz edin.**
```sql
-- SORU 7 CEVABI:
WITH SALARY_ANALYSIS AS (
    SELECT FIRST_NAME, LAST_NAME, SALARY,
           ROW_NUMBER() OVER (ORDER BY SALARY DESC) AS RANK_NUM,
           SUM(SALARY) OVER (ORDER BY SALARY DESC ROWS UNBOUNDED PRECEDING) AS RUNNING_TOTAL,
           SUM(SALARY) OVER () AS TOTAL_SALARY,
           COUNT(*) OVER () AS TOTAL_EMPLOYEES
    FROM HR.EMPLOYEES
)
SELECT FIRST_NAME, LAST_NAME, SALARY, RANK_NUM,
       RUNNING_TOTAL,
       ROUND((RUNNING_TOTAL / TOTAL_SALARY) * 100, 2) AS CUMULATIVE_PERCENTAGE,
       ROUND((RANK_NUM / TOTAL_EMPLOYEES) * 100, 2) AS EMPLOYEE_PERCENTAGE,
       CASE 
           WHEN ROUND((RUNNING_TOTAL / TOTAL_SALARY) * 100, 2) <= 50 THEN 'Top 50% Earners'
           WHEN ROUND((RUNNING_TOTAL / TOTAL_SALARY) * 100, 2) <= 80 THEN 'Middle 30% Earners'
           ELSE 'Bottom 20% Earners'
       END AS EARNING_CATEGORY
FROM SALARY_ANALYSIS
ORDER BY RANK_NUM;
```

**8. Kompleks CTE kullanarak departman performans analizi yapÄ±n.**
```sql
-- SORU 8 CEVABI:
WITH DEPT_METRICS AS (
    SELECT DEPARTMENT_ID,
           COUNT(*) AS EMP_COUNT,
           AVG(SALARY) AS AVG_SALARY,
           STDDEV(SALARY) AS SALARY_STDDEV,
           MAX(SALARY) - MIN(SALARY) AS SALARY_RANGE
    FROM HR.EMPLOYEES
    WHERE DEPARTMENT_ID IS NOT NULL
    GROUP BY DEPARTMENT_ID
),
COMPANY_METRICS AS (
    SELECT AVG(AVG_SALARY) AS COMPANY_AVG_SALARY,
           AVG(EMP_COUNT) AS COMPANY_AVG_EMP_COUNT
    FROM DEPT_METRICS
),
DEPT_RANKINGS AS (
    SELECT DEPARTMENT_ID,
           RANK() OVER (ORDER BY AVG_SALARY DESC) AS SALARY_RANK,
           RANK() OVER (ORDER BY EMP_COUNT DESC) AS SIZE_RANK,
           RANK() OVER (ORDER BY SALARY_RANGE DESC) AS DIVERSITY_RANK
    FROM DEPT_METRICS
)
SELECT D.DEPARTMENT_NAME,
       DM.EMP_COUNT,
       ROUND(DM.AVG_SALARY, 2) AS AVG_SALARY,
       ROUND(DM.SALARY_STDDEV, 2) AS SALARY_STDDEV,
       DM.SALARY_RANGE,
       DR.SALARY_RANK,
       DR.SIZE_RANK,
       DR.DIVERSITY_RANK,
       CASE 
           WHEN DM.AVG_SALARY > CM.COMPANY_AVG_SALARY * 1.2 THEN 'High Performing'
           WHEN DM.AVG_SALARY > CM.COMPANY_AVG_SALARY * 0.8 THEN 'Average Performing'
           ELSE 'Below Average'
       END AS PERFORMANCE_CATEGORY
FROM DEPT_METRICS DM
JOIN HR.DEPARTMENTS D ON DM.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN DEPT_RANKINGS DR ON DM.DEPARTMENT_ID = DR.DEPARTMENT_ID
CROSS JOIN COMPANY_METRICS CM
ORDER BY DR.SALARY_RANK;
```

---

## **8. OTURUM: PRATÄ°K UYGULAMALAR VE DEÄERLENDÄ°RME**

### KapsamlÄ± Senaryolar

### Senaryo 1: Ä°K Raporu - KapsamlÄ± Departman Analizi
```sql
-- Departman bazÄ±nda kapsamlÄ± analiz (tÃ¼m HR tablolarÄ±nÄ± kullanan)
WITH DEPT_ANALYSIS AS (
    SELECT 
        D.DEPARTMENT_ID,
        D.DEPARTMENT_NAME,
        L.CITY,
        C.COUNTRY_NAME,
        R.REGION_NAME,
        COUNT(E.EMPLOYEE_ID) AS TOTAL_EMPLOYEES,
        ROUND(AVG(E.SALARY), 2) AS AVG_SALARY,
        MIN(E.SALARY) AS MIN_SALARY,
        MAX(E.SALARY) AS MAX_SALARY,
        COUNT(CASE WHEN E.COMMISSION_PCT IS NOT NULL THEN 1 END) AS COMMISSION_EMPLOYEES,
        ROUND(AVG(MONTHS_BETWEEN(SYSDATE, E.HIRE_DATE)/12), 1) AS AVG_TENURE_YEARS,
        COUNT(DISTINCT E.JOB_ID) AS UNIQUE_JOBS,
        COUNT(CASE WHEN E.MANAGER_ID IS NULL THEN 1 END) AS TOP_MANAGERS
    FROM HR.DEPARTMENTS D
    JOIN HR.LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
    JOIN HR.COUNTRIES C ON L.COUNTRY_ID = C.COUNTRY_ID
    JOIN HR.REGIONS R ON C.REGION_ID = R.REGION_ID
    LEFT JOIN HR.EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
    GROUP BY D.DEPARTMENT_ID, D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME, R.REGION_NAME
)
SELECT 
    DEPARTMENT_NAME,
    CITY,
    COUNTRY_NAME,
    REGION_NAME,
    TOTAL_EMPLOYEES,
    AVG_SALARY,
    MIN_SALARY,
    MAX_SALARY,
    COMMISSION_EMPLOYEES,
    AVG_TENURE_YEARS,
    UNIQUE_JOBS,
    TOP_MANAGERS,
    CASE 
        WHEN AVG_SALARY > 8000 THEN 'YÃ¼ksek MaaÅŸ'
        WHEN AVG_SALARY > 5000 THEN 'Orta MaaÅŸ'
        ELSE 'DÃ¼ÅŸÃ¼k MaaÅŸ'
    END AS SALARY_CATEGORY,
    ROUND((TOTAL_EMPLOYEES * 100.0) / SUM(TOTAL_EMPLOYEES) OVER (), 2) AS EMPLOYEE_PERCENTAGE
FROM DEPT_ANALYSIS
ORDER BY AVG_SALARY DESC;
```

### Senaryo 2: Performans DeÄŸerlendirmesi ve Kariyer Analizi
```sql
-- Ã‡alÄ±ÅŸan performans sÄ±ralamasÄ± ve kariyer analizi
WITH EMPLOYEE_PERFORMANCE AS (
    SELECT 
        E.EMPLOYEE_ID,
        E.FIRST_NAME || ' ' || E.LAST_NAME AS FULL_NAME,
        E.SALARY,
        E.HIRE_DATE,
        D.DEPARTMENT_NAME,
        J.JOB_TITLE,
        L.CITY,
        C.COUNTRY_NAME,
        -- Departman iÃ§inde maaÅŸ sÄ±ralamasÄ±
        RANK() OVER (PARTITION BY E.DEPARTMENT_ID ORDER BY E.SALARY DESC) AS DEPT_SALARY_RANK,
        -- Åirket genelinde maaÅŸ sÄ±ralamasÄ±
        PERCENT_RANK() OVER (ORDER BY E.SALARY) AS COMPANY_SALARY_PERCENTILE,
        -- Ã‡alÄ±ÅŸma sÃ¼resi
        ROUND(MONTHS_BETWEEN(SYSDATE, E.HIRE_DATE)/12, 1) AS TENURE_YEARS,
        -- Departman ortalama maaÅŸÄ±yla karÅŸÄ±laÅŸtÄ±rma
        E.SALARY - AVG(E.SALARY) OVER (PARTITION BY E.DEPARTMENT_ID) AS SALARY_DIFF_FROM_DEPT_AVG,
        -- Ä°ÅŸ deÄŸiÅŸikliÄŸi sayÄ±sÄ±
        (SELECT COUNT(*) FROM HR.JOB_HISTORY JH WHERE JH.EMPLOYEE_ID = E.EMPLOYEE_ID) AS JOB_CHANGES,
        -- MaaÅŸ kategorisi
        NTILE(5) OVER (ORDER BY E.SALARY) AS SALARY_QUINTILE
    FROM HR.EMPLOYEES E
    JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
    JOIN HR.JOBS J ON E.JOB_ID = J.JOB_ID
    JOIN HR.LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
    JOIN HR.COUNTRIES C ON L.COUNTRY_ID = C.COUNTRY_ID
)
SELECT 
    FULL_NAME,
    DEPARTMENT_NAME,
    JOB_TITLE,
    CITY,
    COUNTRY_NAME,
    SALARY,
    DEPT_SALARY_RANK,
    ROUND(COMPANY_SALARY_PERCENTILE * 100, 1) AS SALARY_PERCENTILE,
    TENURE_YEARS,
    ROUND(SALARY_DIFF_FROM_DEPT_AVG, 2) AS DIFF_FROM_DEPT_AVG,
    JOB_CHANGES,
    SALARY_QUINTILE,
    CASE 
        WHEN COMPANY_SALARY_PERCENTILE >= 0.9 THEN 'Top Performer'
        WHEN COMPANY_SALARY_PERCENTILE >= 0.7 THEN 'High Performer'
        WHEN COMPANY_SALARY_PERCENTILE >= 0.5 THEN 'Average Performer'
        ELSE 'Below Average'
    END AS PERFORMANCE_CATEGORY,
    CASE 
        WHEN JOB_CHANGES > 2 THEN 'High Mobility'
        WHEN JOB_CHANGES > 0 THEN 'Some Mobility'
        ELSE 'No Job Changes'
    END AS CAREER_MOBILITY
FROM EMPLOYEE_PERFORMANCE
ORDER BY COMPANY_SALARY_PERCENTILE DESC;
```

### Senaryo 3: Global Ä°ÅŸe AlÄ±m ve Lokasyon Analizi
```sql
-- BÃ¶lgesel iÅŸe alÄ±m trendleri ve lokasyon analizi
WITH HIRING_ANALYSIS AS (
    SELECT 
        R.REGION_NAME,
        C.COUNTRY_NAME,
        L.CITY,
        D.DEPARTMENT_NAME,
        EXTRACT(YEAR FROM E.HIRE_DATE) AS HIRE_YEAR,
        COUNT(E.EMPLOYEE_ID) AS HIRES,
        AVG(E.SALARY) AS AVG_STARTING_SALARY,
        MIN(E.HIRE_DATE) AS FIRST_HIRE,
        MAX(E.HIRE_DATE) AS LAST_HIRE
    FROM HR.REGIONS R
    JOIN HR.COUNTRIES C ON R.REGION_ID = C.REGION_ID
    JOIN HR.LOCATIONS L ON C.COUNTRY_ID = L.COUNTRY_ID
    JOIN HR.DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID
    JOIN HR.EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
    GROUP BY R.REGION_NAME, C.COUNTRY_NAME, L.CITY, D.DEPARTMENT_NAME, EXTRACT(YEAR FROM E.HIRE_DATE)
),
REGIONAL_TOTALS AS (
    SELECT 
        REGION_NAME,
        HIRE_YEAR,
        SUM(HIRES) AS TOTAL_REGIONAL_HIRES
    FROM HIRING_ANALYSIS
    GROUP BY REGION_NAME, HIRE_YEAR
)
SELECT 
    HA.REGION_NAME,
    HA.COUNTRY_NAME,
    HA.CITY,
    HA.DEPARTMENT_NAME,
    HA.HIRE_YEAR,
    HA.HIRES,
    RT.TOTAL_REGIONAL_HIRES,
    ROUND((HA.HIRES * 100.0 / RT.TOTAL_REGIONAL_HIRES), 1) AS DEPT_HIRE_PERCENTAGE,
    ROUND(HA.AVG_STARTING_SALARY, 2) AS AVG_STARTING_SALARY,
    HA.FIRST_HIRE,
    HA.LAST_HIRE
FROM HIRING_ANALYSIS HA
JOIN REGIONAL_TOTALS RT ON HA.REGION_NAME = RT.REGION_NAME AND HA.HIRE_YEAR = RT.HIRE_YEAR
WHERE HA.HIRE_YEAR IS NOT NULL
ORDER BY HA.HIRE_YEAR DESC, HA.REGION_NAME, HA.HIRES DESC;
```

### Senaryo 4: Organizasyon HiyerarÅŸisi ve YÃ¶netim Analizi
```sql
-- YÃ¶netim hiyerarÅŸisi ve span of control analizi
WITH MANAGEMENT_HIERARCHY AS (
    -- YÃ¶netici seviye analizi
    SELECT 
        MGR.EMPLOYEE_ID AS MANAGER_ID,
        MGR.FIRST_NAME || ' ' || MGR.LAST_NAME AS MANAGER_NAME,
        MGR.JOB_TITLE AS MANAGER_TITLE,
        D.DEPARTMENT_NAME,
        COUNT(EMP.EMPLOYEE_ID) AS DIRECT_REPORTS,
        AVG(EMP.SALARY) AS AVG_SUBORDINATE_SALARY,
        MIN(EMP.SALARY) AS MIN_SUBORDINATE_SALARY,
        MAX(EMP.SALARY) AS MAX_SUBORDINATE_SALARY,
        MGR.SALARY AS MANAGER_SALARY
    FROM HR.EMPLOYEES MGR
    JOIN HR.JOBS MJ ON MGR.JOB_ID = MJ.JOB_ID
    JOIN HR.DEPARTMENTS D ON MGR.DEPARTMENT_ID = D.DEPARTMENT_ID
    LEFT JOIN HR.EMPLOYEES EMP ON MGR.EMPLOYEE_ID = EMP.MANAGER_ID
    GROUP BY MGR.EMPLOYEE_ID, MGR.FIRST_NAME, MGR.LAST_NAME, MJ.JOB_TITLE, 
             D.DEPARTMENT_NAME, MGR.SALARY
),
ORG_LEVELS AS (
    -- Organizasyon seviyelerini hesapla
    SELECT EMPLOYEE_ID, FIRST_NAME, LAST_NAME, MANAGER_ID, 1 AS ORG_LEVEL
    FROM HR.EMPLOYEES
    WHERE MANAGER_ID IS NULL
    
    UNION ALL
    
    SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.MANAGER_ID, OL.ORG_LEVEL + 1
    FROM HR.EMPLOYEES E
    JOIN ORG_LEVELS OL ON E.MANAGER_ID = OL.EMPLOYEE_ID
    WHERE OL.ORG_LEVEL < 5
)
SELECT 
    MH.MANAGER_NAME,
    MH.MANAGER_TITLE,
    MH.DEPARTMENT_NAME,
    MH.DIRECT_REPORTS,
    MH.MANAGER_SALARY,
    ROUND(MH.AVG_SUBORDINATE_SALARY, 2) AS AVG_SUBORDINATE_SALARY,
    MH.MIN_SUBORDINATE_SALARY,
    MH.MAX_SUBORDINATE_SALARY,
    OL.ORG_LEVEL,
    CASE 
        WHEN MH.DIRECT_REPORTS > 10 THEN 'Wide Span'
        WHEN MH.DIRECT_REPORTS > 5 THEN 'Medium Span'
        WHEN MH.DIRECT_REPORTS > 0 THEN 'Narrow Span'
        ELSE 'Individual Contributor'
    END AS SPAN_OF_CONTROL,
    ROUND((MH.MANAGER_SALARY / NULLIF(MH.AVG_SUBORDINATE_SALARY, 0)), 2) AS SALARY_RATIO
FROM MANAGEMENT_HIERARCHY MH
LEFT JOIN ORG_LEVELS OL ON MH.MANAGER_ID = OL.EMPLOYEE_ID
ORDER BY OL.ORG_LEVEL, MH.DIRECT_REPORTS DESC;
```

### Best Practices ve Optimizasyon Ä°puÃ§larÄ±

#### 1. Query Optimization
```sql
-- Index kullanÄ±mÄ±na uygun sorgular (Ã¶rnek index Ã¶nerileri)
-- SÄ±k kullanÄ±lan JOIN'ler iÃ§in:
-- CREATE INDEX idx_emp_dept_id ON HR.EMPLOYEES(DEPARTMENT_ID);
-- CREATE INDEX idx_emp_manager_id ON HR.EMPLOYEES(MANAGER_ID);
-- CREATE INDEX idx_emp_hire_date ON HR.EMPLOYEES(HIRE_DATE);
-- CREATE INDEX idx_dept_location_id ON HR.DEPARTMENTS(LOCATION_ID);

-- EXPLAIN PLAN ile sorgu performansÄ±nÄ± analiz etme
EXPLAIN PLAN FOR
SELECT E.FIRST_NAME, E.LAST_NAME, D.DEPARTMENT_NAME, L.CITY
FROM HR.EMPLOYEES E
JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN HR.LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.SALARY > 5000;

SELECT * FROM TABLE(DBMS_XPLAN.DISPLAY);
```

#### 2. Performans Ä°puÃ§larÄ±
- WHERE koÅŸullarÄ±nÄ± mÃ¼mkÃ¼n olduÄŸunca erken kullanÄ±n
- SELECT *'dan kaÃ§Ä±nÄ±n, sadece ihtiyacÄ±nÄ±z olan sÃ¼tunlarÄ± seÃ§in
- JOIN iÅŸlemlerinde kÃ¼Ã§Ã¼k tablolarÄ± Ã¶nce kullanÄ±n
- Subquery yerine JOIN kullanmayÄ± tercih edin (genellikle daha hÄ±zlÄ±dÄ±r)
- DISTINCT kullanÄ±mÄ±nÄ± minimize edin
- Window functions'larÄ± GROUP BY'dan daha efektif olabilir
- Index'lenen sÃ¼tunlarÄ± WHERE ve JOIN koÅŸullarÄ±nda kullanÄ±n

#### 3. Kod StandartlarÄ±
```sql
-- Ä°yi SQL yazÄ±m pratikleri Ã¶rneÄŸi:
SELECT 
    E.FIRST_NAME,           -- Ã‡alÄ±ÅŸan adÄ±
    E.LAST_NAME,            -- Ã‡alÄ±ÅŸan soyadÄ±
    D.DEPARTMENT_NAME,      -- Departman adÄ±
    J.JOB_TITLE,            -- Ä°ÅŸ unvanÄ±
    L.CITY,                 -- Åehir
    C.COUNTRY_NAME          -- Ãœlke adÄ±
FROM HR.EMPLOYEES E         -- Ana Ã§alÄ±ÅŸan tablosu
    INNER JOIN HR.DEPARTMENTS D 
        ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
    INNER JOIN HR.JOBS J 
        ON E.JOB_ID = J.JOB_ID
    INNER JOIN HR.LOCATIONS L
        ON D.LOCATION_ID = L.LOCATION_ID
    INNER JOIN HR.COUNTRIES C
        ON L.COUNTRY_ID = C.COUNTRY_ID
WHERE E.SALARY > 5000       -- MaaÅŸ filtresi
ORDER BY E.LAST_NAME;       -- Soyada gÃ¶re sÄ±ralama
```

### Final DeÄŸerlendirme SorularÄ±

#### Kolay Seviye (1-3 puan)
```sql
-- 1. TÃ¼m Ã§alÄ±ÅŸanlarÄ±n ad, soyad ve maaÅŸ bilgilerini listeleyin
SELECT FIRST_NAME, LAST_NAME, SALARY FROM HR.EMPLOYEES;

-- 2. MaaÅŸÄ± 6000'den yÃ¼ksek Ã§alÄ±ÅŸanlarÄ± bulun
SELECT * FROM HR.EMPLOYEES WHERE SALARY > 6000;

-- 3. IT departmanÄ±ndaki Ã§alÄ±ÅŸan sayÄ±sÄ±nÄ± hesaplayÄ±n
SELECT COUNT(*) FROM HR.EMPLOYEES WHERE JOB_ID LIKE 'IT%';
```

#### Orta Seviye (4-6 puan)
```sql
-- 4. Her departmandaki ortalama maaÅŸÄ± departman adÄ±yla birlikte gÃ¶sterin
SELECT D.DEPARTMENT_NAME, ROUND(AVG(E.SALARY), 2) AS AVG_SALARY
FROM HR.EMPLOYEES E
JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
GROUP BY D.DEPARTMENT_NAME;

-- 5. En yÃ¼ksek maaÅŸlÄ± Ã§alÄ±ÅŸanÄ±n tÃ¼m bilgilerini getirin
SELECT E.*, D.DEPARTMENT_NAME, J.JOB_TITLE
FROM HR.EMPLOYEES E
JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN HR.JOBS J ON E.JOB_ID = J.JOB_ID
WHERE E.SALARY = (SELECT MAX(SALARY) FROM HR.EMPLOYEES);

-- 6. 2005 yÄ±lÄ±ndan sonra iÅŸe alÄ±nan Ã§alÄ±ÅŸanlarÄ± ÅŸehir bilgisiyle listeleyin
SELECT E.FIRST_NAME, E.LAST_NAME, E.HIRE_DATE, L.CITY
FROM HR.EMPLOYEES E
JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
JOIN HR.LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
WHERE E.HIRE_DATE > DATE '2005-12-31';
```

#### Zor Seviye (7-10 puan)
```sql
-- 7. Her departmandaki en yÃ¼ksek maaÅŸlÄ± Ã§alÄ±ÅŸanÄ± bulun
SELECT E.FIRST_NAME, E.LAST_NAME, E.SALARY, D.DEPARTMENT_NAME
FROM HR.EMPLOYEES E
JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE (E.DEPARTMENT_ID, E.SALARY) IN (
    SELECT DEPARTMENT_ID, MAX(SALARY)
    FROM HR.EMPLOYEES
    GROUP BY DEPARTMENT_ID
);

-- 8. BÃ¶lge bazÄ±nda departman sayÄ±sÄ± ve toplam Ã§alÄ±ÅŸan sayÄ±sÄ±nÄ± analiz edin
SELECT R.REGION_NAME,
       COUNT(DISTINCT D.DEPARTMENT_ID) AS DEPT_COUNT,
       COUNT(E.EMPLOYEE_ID) AS TOTAL_EMPLOYEES,
       ROUND(AVG(E.SALARY), 2) AS AVG_SALARY
FROM HR.REGIONS R
JOIN HR.COUNTRIES C ON R.REGION_ID = C.REGION_ID
JOIN HR.LOCATIONS L ON C.COUNTRY_ID = L.COUNTRY_ID
JOIN HR.DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID
LEFT JOIN HR.EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY R.REGION_NAME
ORDER BY TOTAL_EMPLOYEES DESC;

-- 9. Ã‡alÄ±ÅŸanlarÄ±n maaÅŸ sÄ±ralamasÄ±nÄ± ve departman iÃ§indeki pozisyonlarÄ±nÄ± gÃ¶steren bir sorgu yazÄ±n
SELECT E.FIRST_NAME, E.LAST_NAME, E.SALARY, D.DEPARTMENT_NAME,
       RANK() OVER (ORDER BY E.SALARY DESC) AS COMPANY_RANK,
       RANK() OVER (PARTITION BY E.DEPARTMENT_ID ORDER BY E.SALARY DESC) AS DEPT_RANK,
       ROUND(PERCENT_RANK() OVER (ORDER BY E.SALARY) * 100, 2) AS SALARY_PERCENTILE
FROM HR.EMPLOYEES E
JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY E.SALARY DESC;

-- 10. Ä°ÅŸ geÃ§miÅŸi olan Ã§alÄ±ÅŸanlarÄ±n kariyer hareketliliÄŸini analiz edin
WITH JOB_CHANGES AS (
    SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.SALARY,
           COUNT(JH.EMPLOYEE_ID) AS JOB_CHANGE_COUNT,
           MIN(JH.START_DATE) AS FIRST_JOB_START,
           MAX(JH.END_DATE) AS LAST_JOB_END
    FROM HR.EMPLOYEES E
    LEFT JOIN HR.JOB_HISTORY JH ON E.EMPLOYEE_ID = JH.EMPLOYEE_ID
    GROUP BY E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.SALARY
)
SELECT FIRST_NAME, LAST_NAME, SALARY, JOB_CHANGE_COUNT,
       CASE 
           WHEN JOB_CHANGE_COUNT > 2 THEN 'High Mobility'
           WHEN JOB_CHANGE_COUNT > 0 THEN 'Some Mobility'
           ELSE 'No Job Changes'
       END AS MOBILITY_LEVEL,
       FIRST_JOB_START, LAST_JOB_END
FROM JOB_CHANGES
ORDER BY JOB_CHANGE_COUNT DESC, SALARY DESC;
```

## ğŸ‹ï¸ **OTURUM 8 - FÄ°NAL ALIÅTIRMALARI**

### **KOLAY SEVÄ°YE (3 Soru)**

**1. Åirketin genel istatistiklerini Ã¶zetleyin.**
```sql
-- SORU 1 CEVABI:
SELECT 
    (SELECT COUNT(*) FROM HR.EMPLOYEES) AS TOTAL_EMPLOYEES,
    (SELECT COUNT(DISTINCT DEPARTMENT_ID) FROM HR.EMPLOYEES WHERE DEPARTMENT_ID IS NOT NULL) AS ACTIVE_DEPARTMENTS,
    (SELECT COUNT(*) FROM HR.DEPARTMENTS) AS TOTAL_DEPARTMENTS,
    (SELECT COUNT(DISTINCT JOB_ID) FROM HR.EMPLOYEES) AS DIFFERENT_JOBS,
    (SELECT COUNT(DISTINCT COUNTRY_ID) FROM HR.LOCATIONS) AS COUNTRIES_WITH_OFFICES,
    TO_CHAR((SELECT SUM(SALARY) FROM HR.EMPLOYEES), '999,999,999') AS TOTAL_SALARY_COST,
    TO_CHAR((SELECT AVG(SALARY) FROM HR.EMPLOYEES), '999,999.99') AS AVERAGE_SALARY
FROM DUAL;
```

**2. Departman bazÄ±nda basit Ã¶zet raporu oluÅŸturun.**
```sql
-- SORU 2 CEVABI:
SELECT D.DEPARTMENT_NAME,
       COUNT(E.EMPLOYEE_ID) AS EMP_COUNT,
       TO_CHAR(SUM(NVL(E.SALARY, 0)), '999,999,999') AS TOTAL_COST,
       TO_CHAR(AVG(E.SALARY), '999,999.99') AS AVG_SALARY,
       L.CITY,
       C.COUNTRY_NAME
FROM HR.DEPARTMENTS D
LEFT JOIN HR.EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
LEFT JOIN HR.LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
LEFT JOIN HR.COUNTRIES C ON L.COUNTRY_ID = C.COUNTRY_ID
GROUP BY D.DEPARTMENT_NAME, L.CITY, C.COUNTRY_NAME
ORDER BY EMP_COUNT DESC;
```

**3. En popÃ¼ler iÅŸe alÄ±m aylarÄ±nÄ± bulun.**
```sql
-- SORU 3 CEVABI:
SELECT TO_CHAR(HIRE_DATE, 'MONTH') AS HIRE_MONTH,
       EXTRACT(MONTH FROM HIRE_DATE) AS MONTH_NUM,
       COUNT(*) AS HIRES_COUNT,
       ROUND(AVG(SALARY), 2) AS AVG_STARTING_SALARY
FROM HR.EMPLOYEES
GROUP BY TO_CHAR(HIRE_DATE, 'MONTH'), EXTRACT(MONTH FROM HIRE_DATE)
ORDER BY HIRES_COUNT DESC;
```

### **ORTA SEVÄ°YE (3 Soru)**

**4. Departman yÃ¶neticilerinin performans analizi yapÄ±n.**
```sql
-- SORU 4 CEVABI:
WITH MANAGER_ANALYSIS AS (
    SELECT D.DEPARTMENT_NAME,
           MGR.FIRST_NAME || ' ' || MGR.LAST_NAME AS MANAGER_NAME,
           MGR.SALARY AS MANAGER_SALARY,
           COUNT(EMP.EMPLOYEE_ID) AS TEAM_SIZE,
           AVG(EMP.SALARY) AS TEAM_AVG_SALARY,
           MAX(EMP.SALARY) AS TEAM_MAX_SALARY,
           MIN(EMP.SALARY) AS TEAM_MIN_SALARY
    FROM HR.DEPARTMENTS D
    JOIN HR.EMPLOYEES MGR ON D.MANAGER_ID = MGR.EMPLOYEE_ID
    LEFT JOIN HR.EMPLOYEES EMP ON D.DEPARTMENT_ID = EMP.DEPARTMENT_ID AND EMP.EMPLOYEE_ID != MGR.EMPLOYEE_ID
    GROUP BY D.DEPARTMENT_NAME, MGR.FIRST_NAME, MGR.LAST_NAME, MGR.SALARY
)
SELECT DEPARTMENT_NAME, MANAGER_NAME, MANAGER_SALARY, TEAM_SIZE,
       ROUND(TEAM_AVG_SALARY, 2) AS TEAM_AVG_SALARY,
       ROUND(MANAGER_SALARY / NULLIF(TEAM_AVG_SALARY, 0), 2) AS SALARY_RATIO,
       CASE 
           WHEN TEAM_SIZE > 10 THEN 'Large Team'
           WHEN TEAM_SIZE > 5 THEN 'Medium Team'
           WHEN TEAM_SIZE > 0 THEN 'Small Team'
           ELSE 'No Team'
       END AS TEAM_CATEGORY
FROM MANAGER_ANALYSIS
ORDER BY TEAM_SIZE DESC;
```

**5. Global ofis daÄŸÄ±lÄ±mÄ± ve verimlilik analizi yapÄ±n.**
```sql
-- SORU 5 CEVABI:
SELECT R.REGION_NAME, C.COUNTRY_NAME, L.CITY,
       COUNT(DISTINCT D.DEPARTMENT_ID) AS DEPARTMENTS,
       COUNT(E.EMPLOYEE_ID) AS EMPLOYEES,
       ROUND(AVG(E.SALARY), 2) AS AVG_SALARY,
       SUM(E.SALARY) AS TOTAL_SALARY_COST,
       ROUND(COUNT(E.EMPLOYEE_ID) / NULLIF(COUNT(DISTINCT D.DEPARTMENT_ID), 0), 2) AS EMP_PER_DEPT,
       CASE 
           WHEN COUNT(E.EMPLOYEE_ID) > 20 THEN 'Major Office'
           WHEN COUNT(E.EMPLOYEE_ID) > 10 THEN 'Medium Office'
           WHEN COUNT(E.EMPLOYEE_ID) > 0 THEN 'Small Office'
           ELSE 'No Employees'
       END AS OFFICE_SIZE
FROM HR.REGIONS R
JOIN HR.COUNTRIES C ON R.REGION_ID = C.REGION_ID
JOIN HR.LOCATIONS L ON C.COUNTRY_ID = L.COUNTRY_ID
JOIN HR.DEPARTMENTS D ON L.LOCATION_ID = D.LOCATION_ID
LEFT JOIN HR.EMPLOYEES E ON D.DEPARTMENT_ID = E.DEPARTMENT_ID
GROUP BY R.REGION_NAME, C.COUNTRY_NAME, L.CITY
ORDER BY EMPLOYEES DESC;
```

**6. Kariyer geliÅŸim ve hareketlilik analizi yapÄ±n.**
```sql
-- SORU 6 CEVABI:
WITH CAREER_ANALYSIS AS (
    SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.HIRE_DATE,
           COUNT(JH.EMPLOYEE_ID) AS JOB_CHANGES,
           MIN(JH.START_DATE) AS FIRST_JOB_CHANGE,
           MAX(JH.END_DATE) AS LAST_JOB_CHANGE
    FROM HR.EMPLOYEES E
    LEFT JOIN HR.JOB_HISTORY JH ON E.EMPLOYEE_ID = JH.EMPLOYEE_ID
    GROUP BY E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.HIRE_DATE
)
SELECT FIRST_NAME, LAST_NAME, HIRE_DATE, JOB_CHANGES,
       ROUND(MONTHS_BETWEEN(SYSDATE, HIRE_DATE) / 12, 1) AS YEARS_WITH_COMPANY,
       CASE 
           WHEN JOB_CHANGES = 0 THEN 'No Internal Movement'
           WHEN JOB_CHANGES = 1 THEN 'One Promotion/Transfer'
           WHEN JOB_CHANGES >= 2 THEN 'High Internal Mobility'
       END AS MOBILITY_CATEGORY,
       FIRST_JOB_CHANGE, LAST_JOB_CHANGE
FROM CAREER_ANALYSIS
ORDER BY JOB_CHANGES DESC, YEARS_WITH_COMPANY DESC;
```

### **ZOR SEVÄ°YE (2 Soru)**

**7. Comprehensive Ä°K Dashboard - KapsamlÄ± Ä°nsan KaynaklarÄ± Panosu**
```sql
-- SORU 7 CEVABI:
WITH COMPANY_OVERVIEW AS (
    SELECT 
        COUNT(*) AS TOTAL_EMPLOYEES,
        AVG(SALARY) AS AVG_SALARY,
        SUM(SALARY) AS TOTAL_PAYROLL,
        COUNT(DISTINCT DEPARTMENT_ID) AS ACTIVE_DEPARTMENTS,
        AVG(MONTHS_BETWEEN(SYSDATE, HIRE_DATE) / 12) AS AVG_TENURE_YEARS
    FROM HR.EMPLOYEES
),
DEPT_PERFORMANCE AS (
    SELECT DEPARTMENT_ID,
           COUNT(*) AS EMP_COUNT,
           AVG(SALARY) AS DEPT_AVG_SALARY,
           RANK() OVER (ORDER BY AVG(SALARY) DESC) AS SALARY_RANK,
           RANK() OVER (ORDER BY COUNT(*) DESC) AS SIZE_RANK
    FROM HR.EMPLOYEES
    WHERE DEPARTMENT_ID IS NOT NULL
    GROUP BY DEPARTMENT_ID
),
SALARY_DISTRIBUTION AS (
    SELECT 
        COUNT(CASE WHEN SALARY < 5000 THEN 1 END) AS LOW_SALARY,
        COUNT(CASE WHEN SALARY BETWEEN 5000 AND 10000 THEN 1 END) AS MID_SALARY,
        COUNT(CASE WHEN SALARY > 10000 THEN 1 END) AS HIGH_SALARY
    FROM HR.EMPLOYEES
),
TOP_PERFORMERS AS (
    SELECT DEPARTMENT_ID, COUNT(*) AS HIGH_PERFORMERS
    FROM HR.EMPLOYEES
    WHERE SALARY > (SELECT PERCENTILE_CONT(0.8) WITHIN GROUP (ORDER BY SALARY) FROM HR.EMPLOYEES)
    GROUP BY DEPARTMENT_ID
)
SELECT 
    'COMPANY OVERVIEW' AS METRIC_TYPE,
    'Total Employees: ' || CO.TOTAL_EMPLOYEES AS METRIC_VALUE
FROM COMPANY_OVERVIEW CO
UNION ALL
SELECT 'COMPANY OVERVIEW', 'Average Salary: 

---

## ğŸ“š EK KAYNAKLAR

### Oracle SQL FonksiyonlarÄ± ReferansÄ±
- **TO_CHAR**: Tarih ve sayÄ± formatlarÄ± (`TO_CHAR(SYSDATE, 'DD-MON-YYYY')`)
- **DECODE**: KoÅŸullu deÄŸer dÃ¶nÃ¼ÅŸtÃ¼rme (`DECODE(DEPARTMENT_ID, 10, 'Accounting', 'Other')`)
- **REGEXP_LIKE**: DÃ¼zenli ifade eÅŸleÅŸtirme (`WHERE REGEXP_LIKE(EMAIL, '^[A-Z]+@')`)
- **LISTAGG**: String birleÅŸtirme (`LISTAGG(FIRST_NAME, ', ') WITHIN GROUP (ORDER BY FIRST_NAME)`)
- **CONNECT BY**: HiyerarÅŸik sorgular iÃ§in Oracle'a Ã¶zel syntax

### Oracle Live SQL Ä°puÃ§larÄ±
- **Sorgu Kaydetme**: "Save" butonu ile sorgularÄ±nÄ±zÄ± saklayÄ±n
- **GeÃ§miÅŸ**: "History" sekmesinden Ã¶nceki sorgularÄ±nÄ±za ulaÅŸÄ±n
- **PaylaÅŸÄ±m**: "Share" ile sorgularÄ±nÄ±zÄ± baÅŸkalarÄ±yla paylaÅŸÄ±n
- **Export**: "Download" ile sonuÃ§larÄ± CSV/Excel formatÄ±nda indirin
- **Performance**: "Execution Plan" ile sorgu performansÄ±nÄ± inceleyin

### HR Veri TabanÄ± Ä°liÅŸki DiyagramÄ±
```
REGIONS (4 kayÄ±t)
    â†“
COUNTRIES (25 kayÄ±t)
    â†“  
LOCATIONS (23 kayÄ±t)
    â†“
DEPARTMENTS (27 kayÄ±t)
    â†“
EMPLOYEES (107 kayÄ±t) â†â†’ JOB_HISTORY
    â†“
JOBS (19 kayÄ±t)
```

### Pratik Ä°Ã§in Ek Veri Setleri
- **Order Entry (OE)**: E-ticaret, mÃ¼ÅŸteri, sipariÅŸ verileri
- **Sales History (SH)**: SatÄ±ÅŸ analizi, zaman serisi verileri  
- **Product Media (PM)**: ÃœrÃ¼n katalog, medya verileri
- **Information Exchange (IX)**: XML veri iÅŸleme Ã¶rnekleri

### Sonraki Seviye Ä°Ã§in Ã–neriler
1. **PL/SQL Programlama**: Stored procedures, functions, triggers
2. **Database Design**: Normalizasyon, ERD tasarÄ±mÄ±, constraint'ler
3. **Performance Tuning**: Index optimizasyonu, execution plan analizi
4. **Oracle Certifications**: 
   - Oracle Database SQL (1Z0-071)
   - Oracle Database 19c Administrator (1Z0-082, 1Z0-083)
5. **Advanced Analytics**: Oracle Analytics Cloud, OLAP functions
6. **Big Data Integration**: Oracle Big Data tools, Hadoop integration

### EÄŸitim Materyali GÃ¼ncellemeleri
Bu dÃ¶kÃ¼man sÃ¼rekli gÃ¼ncellenmektedir. Son sÃ¼rÃ¼m iÃ§in:
- Oracle Live SQL'deki yeni Ã¶zellikler takip edilir
- SQL standartlarÄ±ndaki deÄŸiÅŸiklikler eklenir  
- Ã–ÄŸrenci geri bildirimlerine gÃ¶re iÃ§erik geliÅŸtirilir
- Real-world senaryolar zenginleÅŸtirilir || TO_CHAR(ROUND(CO.AVG_SALARY, 0), '999,999') FROM COMPANY_OVERVIEW CO
UNION ALL  
SELECT 'COMPANY OVERVIEW', 'Total Payroll: 

---

## ğŸ“š EK KAYNAKLAR

### Oracle SQL FonksiyonlarÄ± ReferansÄ±
- **TO_CHAR**: Tarih ve sayÄ± formatlarÄ± (`TO_CHAR(SYSDATE, 'DD-MON-YYYY')`)
- **DECODE**: KoÅŸullu deÄŸer dÃ¶nÃ¼ÅŸtÃ¼rme (`DECODE(DEPARTMENT_ID, 10, 'Accounting', 'Other')`)
- **REGEXP_LIKE**: DÃ¼zenli ifade eÅŸleÅŸtirme (`WHERE REGEXP_LIKE(EMAIL, '^[A-Z]+@')`)
- **LISTAGG**: String birleÅŸtirme (`LISTAGG(FIRST_NAME, ', ') WITHIN GROUP (ORDER BY FIRST_NAME)`)
- **CONNECT BY**: HiyerarÅŸik sorgular iÃ§in Oracle'a Ã¶zel syntax

### Oracle Live SQL Ä°puÃ§larÄ±
- **Sorgu Kaydetme**: "Save" butonu ile sorgularÄ±nÄ±zÄ± saklayÄ±n
- **GeÃ§miÅŸ**: "History" sekmesinden Ã¶nceki sorgularÄ±nÄ±za ulaÅŸÄ±n
- **PaylaÅŸÄ±m**: "Share" ile sorgularÄ±nÄ±zÄ± baÅŸkalarÄ±yla paylaÅŸÄ±n
- **Export**: "Download" ile sonuÃ§larÄ± CSV/Excel formatÄ±nda indirin
- **Performance**: "Execution Plan" ile sorgu performansÄ±nÄ± inceleyin

### HR Veri TabanÄ± Ä°liÅŸki DiyagramÄ±
```
REGIONS (4 kayÄ±t)
    â†“
COUNTRIES (25 kayÄ±t)
    â†“  
LOCATIONS (23 kayÄ±t)
    â†“
DEPARTMENTS (27 kayÄ±t)
    â†“
EMPLOYEES (107 kayÄ±t) â†â†’ JOB_HISTORY
    â†“
JOBS (19 kayÄ±t)
```

### Pratik Ä°Ã§in Ek Veri Setleri
- **Order Entry (OE)**: E-ticaret, mÃ¼ÅŸteri, sipariÅŸ verileri
- **Sales History (SH)**: SatÄ±ÅŸ analizi, zaman serisi verileri  
- **Product Media (PM)**: ÃœrÃ¼n katalog, medya verileri
- **Information Exchange (IX)**: XML veri iÅŸleme Ã¶rnekleri

### Sonraki Seviye Ä°Ã§in Ã–neriler
1. **PL/SQL Programlama**: Stored procedures, functions, triggers
2. **Database Design**: Normalizasyon, ERD tasarÄ±mÄ±, constraint'ler
3. **Performance Tuning**: Index optimizasyonu, execution plan analizi
4. **Oracle Certifications**: 
   - Oracle Database SQL (1Z0-071)
   - Oracle Database 19c Administrator (1Z0-082, 1Z0-083)
5. **Advanced Analytics**: Oracle Analytics Cloud, OLAP functions
6. **Big Data Integration**: Oracle Big Data tools, Hadoop integration

### EÄŸitim Materyali GÃ¼ncellemeleri
Bu dÃ¶kÃ¼man sÃ¼rekli gÃ¼ncellenmektedir. Son sÃ¼rÃ¼m iÃ§in:
- Oracle Live SQL'deki yeni Ã¶zellikler takip edilir
- SQL standartlarÄ±ndaki deÄŸiÅŸiklikler eklenir  
- Ã–ÄŸrenci geri bildirimlerine gÃ¶re iÃ§erik geliÅŸtirilir
- Real-world senaryolar zenginleÅŸtirilir || TO_CHAR(ROUND(CO.TOTAL_PAYROLL, 0), '999,999,999') FROM COMPANY_OVERVIEW CO
UNION ALL
SELECT 'COMPANY OVERVIEW', 'Average Tenure: ' || TO_CHAR(ROUND(CO.AVG_TENURE_YEARS, 1), '99.9') || ' years' FROM COMPANY_OVERVIEW CO
UNION ALL
SELECT 'SALARY DISTRIBUTION', 'Low Salary (<$5K): ' || SD.LOW_SALARY || ' employees' FROM SALARY_DISTRIBUTION SD
UNION ALL
SELECT 'SALARY DISTRIBUTION', 'Mid Salary ($5K-$10K): ' || SD.MID_SALARY || ' employees' FROM SALARY_DISTRIBUTION SD
UNION ALL
SELECT 'SALARY DISTRIBUTION', 'High Salary (>$10K): ' || SD.HIGH_SALARY || ' employees' FROM SALARY_DISTRIBUTION SD
ORDER BY METRIC_TYPE, METRIC_VALUE;
```

**8. Advanced Predictive Analysis - GeliÅŸmiÅŸ Tahminsel Analiz**
```sql
-- SORU 8 CEVABI:
WITH EMPLOYEE_RISK_ANALYSIS AS (
    SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.LAST_NAME, E.SALARY, E.HIRE_DATE,
           D.DEPARTMENT_NAME, J.JOB_TITLE, L.CITY,
           MONTHS_BETWEEN(SYSDATE, E.HIRE_DATE) / 12 AS TENURE_YEARS,
           E.SALARY / J.MAX_SALARY AS SALARY_CEILING_RATIO,
           (SELECT COUNT(*) FROM HR.EMPLOYEES E2 WHERE E2.MANAGER_ID = E.EMPLOYEE_ID) AS DIRECT_REPORTS,
           CASE WHEN EXISTS (SELECT 1 FROM HR.JOB_HISTORY JH WHERE JH.EMPLOYEE_ID = E.EMPLOYEE_ID) 
                THEN 1 ELSE 0 END AS HAS_JOB_HISTORY,
           -- Risk Factors
           CASE WHEN E.SALARY < (SELECT AVG(SALARY) * 0.8 FROM HR.EMPLOYEES E3 WHERE E3.DEPARTMENT_ID = E.DEPARTMENT_ID) 
                THEN 1 ELSE 0 END AS UNDERPAID_RISK,
           CASE WHEN MONTHS_BETWEEN(SYSDATE, E.HIRE_DATE) / 12 < 2 THEN 1 ELSE 0 END AS NEW_EMPLOYEE_RISK,
           CASE WHEN E.SALARY / J.MAX_SALARY > 0.9 THEN 1 ELSE 0 END AS SALARY_CEILING_RISK
    FROM HR.EMPLOYEES E
    JOIN HR.DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
    JOIN HR.JOBS J ON E.JOB_ID = J.JOB_ID
    JOIN HR.LOCATIONS L ON D.LOCATION_ID = L.LOCATION_ID
),
RETENTION_RISK_SCORING AS (
    SELECT *,
           (UNDERPAID_RISK * 3 + NEW_EMPLOYEE_RISK * 2 + SALARY_CEILING_RISK * 2 + 
            CASE WHEN DIRECT_REPORTS = 0 THEN 1 ELSE 0 END +
            CASE WHEN HAS_JOB_HISTORY = 0 AND TENURE_YEARS > 3 THEN 2 ELSE 0 END) AS RISK_SCORE
    FROM EMPLOYEE_RISK_ANALYSIS
)
SELECT FIRST_NAME, LAST_NAME, DEPARTMENT_NAME, JOB_TITLE, CITY,
       ROUND(SALARY, 0) AS SALARY,
       ROUND(TENURE_YEARS, 1) AS TENURE_YEARS,
       ROUND(SALARY_CEILING_RATIO * 100, 1) AS SALARY_CEILING_PCT,
       DIRECT_REPORTS,
       RISK_SCORE,
       CASE 
           WHEN RISK_SCORE >= 6 THEN 'HIGH RISK - Immediate Attention'
           WHEN RISK_SCORE >= 4 THEN 'MEDIUM RISK - Monitor Closely'
           WHEN RISK_SCORE >= 2 THEN 'LOW RISK - Routine Check'
           ELSE 'STABLE - No Action Required'
       END AS RETENTION_RISK_CATEGORY,
       -- Action Recommendations
       CASE 
           WHEN UNDERPAID_RISK = 1 THEN 'Consider salary adjustment; '
           ELSE ''
       END ||
       CASE 
           WHEN SALARY_CEILING_RISK = 1 THEN 'Career advancement opportunities; '
           ELSE ''
       END ||
       CASE 
           WHEN NEW_EMPLOYEE_RISK = 1 THEN 'Enhanced onboarding and mentoring; '
           ELSE ''
       END ||
       CASE 
           WHEN DIRECT_REPORTS = 0 AND TENURE_YEARS > 5 THEN 'Leadership development opportunities; '
           ELSE ''
       END AS RECOMMENDED_ACTIONS
FROM RETENTION_RISK_SCORING
ORDER BY RISK_SCORE DESC, SALARY DESC;
```

### Sertifika Ä°Ã§in Gereksinimler
- âœ… TÃ¼m 8 oturumdaki alÄ±ÅŸtÄ±rmalarÄ± tamamlamÄ±ÅŸ olma 
- âœ… Her oturumdan en az **kolay seviye** sorularÄ±nÄ±n %80'ini doÄŸru yapma
- âœ… **Orta seviye** sorularÄ±nÄ±n en az %60'Ä±nÄ± doÄŸru yapma  
- âœ… **Zor seviye** sorularÄ±nÄ±n en az %40'Ä±nÄ± doÄŸru yapma
- âœ… Final deÄŸerlendirme sorularÄ±ndan en az 7 tanesini doÄŸru yapma
- âœ… Bir kapsamlÄ± proje senaryosu geliÅŸtirme

### Bonus Proje: Kendi Analizinizi YapÄ±n
Ã–ÄŸrenciler aÅŸaÄŸÄ±daki konulardan birini seÃ§erek kendi analiz sorgularÄ±nÄ± yazabilirler:
1. **MaaÅŸ EÅŸitsizliÄŸi Analizi**: Departman, lokasyon bazÄ±nda maaÅŸ farklarÄ±nÄ± analiz edin
2. **Ã‡alÄ±ÅŸan Tutma OranlarÄ±**: Departman ve yÄ±l bazÄ±nda iÅŸten ayrÄ±lma trendlerini inceleyin  
3. **CoÄŸrafi DaÄŸÄ±lÄ±m Optimizasyonu**: Hangi bÃ¶lgelerde daha fazla iÅŸe alÄ±m yapÄ±lmalÄ±?
4. **Kariyer GeliÅŸim YollarÄ±**: En baÅŸarÄ±lÄ± kariyer yollarÄ±nÄ± tespit edin
5. **Performans ve Verimlilik Analizi**: Departman bazÄ±nda ROI hesaplamalarÄ± yapÄ±n

---

## ğŸ“š EK KAYNAKLAR

### Oracle SQL FonksiyonlarÄ± ReferansÄ±
- **TO_CHAR**: Tarih ve sayÄ± formatlarÄ± (`TO_CHAR(SYSDATE, 'DD-MON-YYYY')`)
- **DECODE**: KoÅŸullu deÄŸer dÃ¶nÃ¼ÅŸtÃ¼rme (`DECODE(DEPARTMENT_ID, 10, 'Accounting', 'Other')`)
- **REGEXP_LIKE**: DÃ¼zenli ifade eÅŸleÅŸtirme (`WHERE REGEXP_LIKE(EMAIL, '^[A-Z]+@')`)
- **LISTAGG**: String birleÅŸtirme (`LISTAGG(FIRST_NAME, ', ') WITHIN GROUP (ORDER BY FIRST_NAME)`)
- **CONNECT BY**: HiyerarÅŸik sorgular iÃ§in Oracle'a Ã¶zel syntax

### Oracle Live SQL Ä°puÃ§larÄ±
- **Sorgu Kaydetme**: "Save" butonu ile sorgularÄ±nÄ±zÄ± saklayÄ±n
- **GeÃ§miÅŸ**: "History" sekmesinden Ã¶nceki sorgularÄ±nÄ±za ulaÅŸÄ±n
- **PaylaÅŸÄ±m**: "Share" ile sorgularÄ±nÄ±zÄ± baÅŸkalarÄ±yla paylaÅŸÄ±n
- **Export**: "Download" ile sonuÃ§larÄ± CSV/Excel formatÄ±nda indirin
- **Performance**: "Execution Plan" ile sorgu performansÄ±nÄ± inceleyin

### HR Veri TabanÄ± Ä°liÅŸki DiyagramÄ±
```
REGIONS (4 kayÄ±t)
    â†“
COUNTRIES (25 kayÄ±t)
    â†“  
LOCATIONS (23 kayÄ±t)
    â†“
DEPARTMENTS (27 kayÄ±t)
    â†“
EMPLOYEES (107 kayÄ±t) â†â†’ JOB_HISTORY
    â†“
JOBS (19 kayÄ±t)
```

### Pratik Ä°Ã§in Ek Veri Setleri
- **Order Entry (OE)**: E-ticaret, mÃ¼ÅŸteri, sipariÅŸ verileri
- **Sales History (SH)**: SatÄ±ÅŸ analizi, zaman serisi verileri  
- **Product Media (PM)**: ÃœrÃ¼n katalog, medya verileri
- **Information Exchange (IX)**: XML veri iÅŸleme Ã¶rnekleri

### Sonraki Seviye Ä°Ã§in Ã–neriler
1. **PL/SQL Programlama**: Stored procedures, functions, triggers
2. **Database Design**: Normalizasyon, ERD tasarÄ±mÄ±, constraint'ler
3. **Performance Tuning**: Index optimizasyonu, execution plan analizi
4. **Oracle Certifications**: 
   - Oracle Database SQL (1Z0-071)
   - Oracle Database 19c Administrator (1Z0-082, 1Z0-083)
5. **Advanced Analytics**: Oracle Analytics Cloud, OLAP functions
6. **Big Data Integration**: Oracle Big Data tools, Hadoop integration

### EÄŸitim Materyali GÃ¼ncellemeleri
Bu dÃ¶kÃ¼man sÃ¼rekli gÃ¼ncellenmektedir. Son sÃ¼rÃ¼m iÃ§in:
- Oracle Live SQL'deki yeni Ã¶zellikler takip edilir
- SQL standartlarÄ±ndaki deÄŸiÅŸiklikler eklenir  
- Ã–ÄŸrenci geri bildirimlerine gÃ¶re iÃ§erik geliÅŸtirilir
- Real-world senaryolar zenginleÅŸtirilir